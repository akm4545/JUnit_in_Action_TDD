# **스텁을 활용한 거친 테스트**  
특정한 런타임 환경에 의존하는 애플리케이션을 위한 단위 테스트를 작성하기는 매우 어렵다. 테스트는 안정적이어야 하며 반복적으로  
수행해도 같은 결과가 나와야 하기 떄문이다. 즉 테스트가 실행되는 환경을 제어할 필요가 있는데 이를 위한 방법으로는 실제로 필요한  
환경을 테스트의 일부로 구성하여 테스트를 수행하는 것이다. 때로는 이런 방식이 효과적일 수 있다. 개발 주기로 보자면 개발 단계나  
빌드 단계에서 실제 환경을 제공하는 것도 물론 도음이 된다. 그러나 이는 항상 가능한 방법은 아니다.  
  
예를 들어 개발 중인 애플리케이션이 타사에서 제공하는 웹 서버에 HTTP 통신을 해야 하는 경우 개발 환경에서는 그런 서버 통신을  
하는 것이 사실상 불가능하다. 이때 타사의 웹 서버를 모사하거나 가짜를 만들어 메꿀 수 있다. 가짜 객체를 황용하는 방법은 크게  
두 가지다. 하나는 스텁을 활용하는 것이고 다른 하나는 모의 객체를 활용하는 것이다.  
  
스텁을 사용한다면 스텁이 사전에 정의된 동작만을 수행한다는 점을 유의해야 한다. 스텁 코드는 테스트 외부에 만들어져 있으며  
사용하는 위치나 횟수와 관계없이 동일한 동작을 수행하는데 일반적으로 하드코딩한 값을 반환한다. 스텁으로 테스트할 때는  
스텁 초기화 -> 테스트 실행 -> 단언문 검증 순서로 진행한다.  
  
모의 객체는 사전에 정의된 동작을 수행하지는 않는다. 대신 테스트 실행 중에 모의 객체가 수행할 행동을 기대할 수 있다. 다른  
테스트를 실행하고 모의 객체를 다시 초기화한 뒤 새로운 행동을 기대하는 것도 가능하다. 모의 객체로 테스트할 때는   
모의 객체 초기화 -> 기대 설정 -> 테스트 실행 -> 단언문 검증 순서로 진행한다.  
  
# **스텁 살펴보기**  
스텁은 실제 코드 혹은 아직 구현되지 않은 코드의 동작을 가장하기 위한 장치이다. 시스템의 일부를 사용할 수 없는  
상황에서 테스트하기 위해 스텁을 할용한다. 일반적으로 스텁은 테스트 대상 코드를 변경하지는 않는다. 대신 애플리케이션에서  
빠진 부분을 빈틈없이 채워주는 역할을 한다.  
  
스텁은 호출자를 실제 구현 코드에서부터 격리하기 위해 실제 코드 대신 런타임에 동작하는 코드를 말한다. 단순하게  
만든 스텁으로 실제 코드의 복잡한 기능을 대체하면 애플리케이션에 독립적으로 테스트를 수행할 수 있다.  
  
스텁을 활용하기 좋은 경우는 다음과 같다.  
- 기존 시스템이 너무 복잡하고 깨지기 쉬워 수정이 어려울 때  
- 소스 코드가 통제할 수 없는 외부 환경에 의존하고 있을 때  
- 파일 시스템, 서버, 데이터베이스 같은 외부 시스템을 완전히 교체해야 할 때  
- 하위 시스템 간 통합 테스트 같은 거친(coarse-grained) 테스트를 수행해야 할 때
  
스텁을 활용하기 어려운 경우는 다음과 같다.  
- 실패의 원인을 밝힐 수 있는 정확한 에러 메세지를 확인하기 위해 세밀한(fine-grained)테스트가 필요할 때  
- 코드 전체가 아니라 일부분만 격리해 테스트를 수행해야 할 때  
  
이런 상황에서는 스텁보다 모의 객체를 사용하는 것이 좋다.  
  
일반적으로 스텁은 테스트가 많이 되어 있는 시스템에서 신뢰도가 높은 편이다. 스텁을 활용하면 테스트 대상 객체를  
수정하지 않으면서도 실제 운영에서 실행되는 것과 동일한 소스를 테스트할 수 있다는 장점이 있다. 실제 실행 중인  
환경에서 자동화된 빌드를 통해서 혹은 개발자가 수동으로 테스트를 수행했을 때 스텁을 활용해 테스트를 실행하면  
개발에 확신을 얻을 수 있다.  
  
스텁의 단점은 작성하기가 까다롭다는 것이다. 가장해야 하는 시스템이 복잡할 때는 더욱 그러하다. 스텁은 모사해야 하는  
코드를 간단하고 단순한 방식으로 구현해야 하므로 비즈니스 로직이 복잡하다면 스텁이 적합하지 않다.  
  
스텁을 활용했을 때의 단점은 다음과 같다.  
- 스텁은 작성하기가 까다로워서 스텁 자체를 디버깅해야 하는 일이 종종 생긴다.  
- 스텁이 복잡해져서 유지 보수하기가 어려울 수 있다.  
- 스텁은 세밀한 단위 테스트에는 적합하지 않을 수 있다.  
- 테스트에 따라 다른 스텁을 만들어야 할 수도 있다.  
일반적으로 스텁은 거친 테스트를 수행하는 데 모의 객체보다 선호된다.  
  
coarse-grained는 일반적으로 결이 거친, 성긴 이라는 의미를 가진다. 특히 소프트웨어 개발에서는 비교적 큰 단위의  
대상을 표현할 때 쓰이는데 여기서는 시스템이나 애플리케이션의 개별적인 단위보다는 여러 컴포넌트 혹은 시스템의  
상당 부분을 의미한다.  
  
# **스텁으로 HTTP 연결 테스트하기**  
특정 URL에 대한 HTTP 연결을 맺은 다음 웹 콘텐츠를 읽어 오는 애플리케이션을 개발 중이라고 가정한다.  
WebClient.getContent 메서드를 사용하여 원격 웹 리소스에 대한 HTTP 연결을 맺는다. 이때 원격 웹  
리소스는 HTML 응답을 생성하는 서블릿 코드를 말한다. 개발자는 웹 리소스를 스텁으로 만들어 getContent 메서드를  
단위 테스트하려고 한다. 웹 리소스는 구현이 되어 있지 않아 개발자는 웹 리소스 없이 개발을 진행해야 한다.  
이때 개발자는 앞으로 서블릿이 제공할 웹 리소스를 단순한 HTML을 반환하는 페이지로 대체한다. 이 HTML 페이지가  
스텁이 된다. getContent 메서드를 테스트하는 것과 getContent 메서드가 실제로 반환할 웹 리소스의 구현을  
서로 독립적으로 만들 수 있다.  
  
스텁으로 교체할 때 중요한 점은 원본 메서드는 수정하지 않는다는 것이다. 즉 테스트 대상 애플리케이션을 수정하지  
않았다. 만약 스텁으로 대체하는 것이 가능하려면 스텁으로 대체할 코드에 잘 정의된 인터페이스가 있는 것이 좋고  
스텁을 구현할 수 있도록 다양한 구현체를 생성하는 것이 허용되어야 한다.  
  
스텁이자 단위 테스트할 애플리케이션의 일부 예제  
WebClient 클래스 참조  
  
# **무엇을 스텁으로 대체할 것인가**  
예제로 제시된 애플리케이션에는 두 가지 경우의 수가 있다. 웹 서버가 (파트너 사이트같이) 개발 플랫폼 외부에 존재하거나  
웹 서버가 애플리케이션이 배포될 플랫폼의 일부일 수 있다. 그러나 어떤 경우가 되더라도 WebClient 클래스를 단위  
테스트할 수 있도록 개발 플랫폼에 구동 가능한 서버가 있어야 한다. 이때 상대적으로 쉬운 해결책은 스텁으로 사용할  
아파치 테스트 서버를 설치하고 테스트 서버에서 기본으로 보여 줄 간단한 웹 페이지를 만드는 것이다. 이런 방법은  
전형적이고 일반적으로 자주 사용되지만 단점이 있다.  
  
단점  
- 환경에 의존한다: 테스트가 시작되기 전에 전체 환경이 구성되어 있고 실행 중인지 확인해야 한다. 만약 웹 서버가  
다운된 상태에서 테스트를 실행하면 테스트는 반드시 실패한다. 그럼 테스트가 실패한 이유를 찾느라 시간을 허비하게 된다.  
단위 테스트를 실행할 때 중요한 점은 테스트 결과를 차후에 똑같이 재현할 수 있도록 테스트를 실행하는 환경을 최대한  
똑같이 유지해야 한다는 것이다.  
- 테스트 로직이 분리되어 있다: 예제의 경우 스텁을 사용하면 테스트 로직이 테스트 케이스와 테스트 웹 페이지 두  
곳으로 흩어진다. 그러므로 테스트를 성공적으로 수행하려면 흩어져 있는 리소스 모두를 항상 최신 상태로 유지해야  
한다는 불편함이 있다.
- 테스트를 자동화히기 어렵다: 웹 페이지를 웹 서버에 배포하고 웹 서버를 기동한 다음 단위 테스트를 실행해야  
하므로 테스트 자동화가 어려울 수 있다.  
  
내장 웹 서버를 사용하여 단점을 해결할 수 있다. 테스트가 자바로 작성되었으므로 테스트에 사용할 수 있는 자바 기반의  
내장 웹 서버를 사용하면 간단히 해결할 수 있다.  
  
# **Jetty를 내장 웹 서버로 활용하기**  
Jetty는 충분히 가볍고 빠른데다가(테스트를 수행할 때 속도는 중요하다) 테스트 코드에서 직접 프로그래밍할 수 있어서  
인기가 많다. 또한 Jetty는 운영 환경에서도 사용할 수 있는 매우 유용한 서블릿 컨테이너이기도 하다.  
  
Jetty를 사용하면 앞에서 언급한 단점을 일부 보완할 수 있다. JUnit5 테스트 코드에서 서버를 구동하고 자바로  
테스트를 작성한 다음 테스트 묶음을 자동화할 수 있기 때문이다. Jetty는 모듈화된 아키텍처를 갖고 있으므로  
개발자는 전체 서버를 만들 필요 없이 Jetty 핸들러만 스텁으로 만들면 된다.  
  
Jetty 구동 방법  
JettySample 참조  
  
# **스텁으로 웹 서버 리소스 만들기**  
# **첫 번째 스텁 설정하기**  
WebClient 클래스가 잘 작동하지는 확인하고 싶다면 사전에 Jetty 서버를 구동해야 한다.  
  
WebClient 클래스가 유효한 경로로 작동하는지 검증하기 위한 테스트 스켈레톤  
TestWebClientSkeleton 클래스 참조  
  
# **사용자 정의 핸들러를 사용하도록 Jetty 구성하기**  
TestWebClient 클래스 참조  
  
# **첫 번째 스텁 테스트 되짚어 보기**  
이전 예제에서 웹 리소스를 스텁으로 만들어 격리된 상태에서 getContent 메서드를 테스트해 볼 수 있었다.  
그 결과 메서드를 단위 테스트하는 동시에 통합 테스트를 수행할 수 있었다. 비즈니스 로직뿐만 아니라  
HttpURLConnection 클래스를 통해 코드 외부에 있는 HTTP 연결 부분도 테스트했다.  
  
이런 접근 방법도 문제는 있는데 바로 복잡하다는 것이다. 만약 개발자가 Jetty를 잘 다루지 못하는 초보라면 환경 설정에 시간이  
걸릴 수 있다. 어떤 경우에는 스텁이 올바르게 작동하는지 확인하기 위해 스텁을 디버깅해야 할 수도 있다. 명심할 점은 스텁은  
단순하게 만들어야 하며 애플리케이션 개발에 들이는 것만큼의 노력을 스텁을 테스트하고 유지 보수하는 데 들여서는 안된다는 것이다.  
스텁을 디버깅하는 데 너무 많은 시간을 쓰고 있다면 다른 방법을 찾아야 한다.  
  
예제에서는 웹 서버가 필요했지만 애플리케이션이 바뀌면 스텁도 달라져야 하고 설정도 바뀌어야 한다.  
예제의 테스트도 훌륭하지만 너무 복잡하게 되었다. 통합 테스트를 수행하지 않고 단위 테스트에 집중하는 식으로 가볍게 접근할 수도 있다.  
통합 테스트가 중요하지만 별도의 테스트 묶음이나 기능 테스트의 일부로 실행할 수 있기 때문이다.  
  
# **스텁으로 HTTP 연결 만들기**  
이전 예제에서는 스텁으로 웹 서버 리소스를 만들었다. 이번에는 HTTP 연결을 만든다. 이때 HTTP 연결은 테스트할 수  
없다. 하지만 지금은 상관이 없는데 HTTP 연결을 테스트하는 것은 당장의 관심사가 아니기 떄문이다. 그보다는  
코드를 격리해 테스트하는 것이 중요하다. HTTP 연결은 기능 테스트나 통합 테스트로 차후에 테스트할 수 있다.  
  
코드를 변경하지 않고 HTTP 연결을 스텁으로 대체할 때 자바 URL 클래스나 HttpURLConnection 클래스의 이점을  
취할 수 있다. 다양한 종류의 프로토콜을 처리하기 위한 사용자 정의 프로토콜 핸들러를 구성할 수 있기 떄문이다.  
HttpUrlConnection 클래스에 대한 모든 호출을 스텁으로 만든 클래스로 리다이렉트할 수 있으며 이 클래스는  
테스트에 필요한 모든 것을 반환하게 만들 수 있다.  
  
