# **모의 객체로 테스트하기**  
개별 메서드 단위 테스트 시 다른 환경이나 다른 메서드와 격리하는 것은 좋은 목표다. 이를 위해 스텁을 활용하여 소스  
코드를 웹 서버, 파일 시스템, 데이터베이스 등의 환경에서 격리하여 단위 테스트를 할 수 있었다. 메서드 호출을 다른  
클래스로부터 격리하는 것과 같이 조금 더 세밀한 격리에서는 모의 객체를 사용한다.  
  
모의 객체의 개념은 팀 매키넌, 스티브 프리먼, 필립 크레이그가 XP2000에서 처음 제시했다. 모의 객체를 사용하면  
가능한 한 가장 세밀한 수준에서 테스트를 실행할 수 있다. 각 메서드별로 개별적인 단위 테스트를 만들어 개발하는  
것이 가능하다.  
  
# **모의 객체란 무엇인가**  
다른 클래스나 메서드와 격리된 상태에서 테스트를 하면 큰 이점이 있다. 작업할 인터페이스가 구성되어 있기만 하다면  
아직 완성되지 않은 코드도 테스트할 수 있다는 것이다. 격리된 상태에서의 테스트는 다른 부분의 코드가 완성되는  
것을 기다리지 않고 한 부분의 코드를 단위 테스트하는 데 큰 도움이 된다.  
  
모의 객체를 사용할 때의 가장 큰 장점은 메서드에 집중하는 테스트를 만들 수 있다는 것이다. 모의 객체를 사용하면  
테스트 대상 메서드가 메서드가 다른 객체를 호출해서 발생하는 부수 효과가 생길 일이 없다. 테스트를 작게, 목표한  
부분만 집중하여 작성하는 것은 이해하기 쉬운 테스트를 만들고 코드의 다른 부분이 변경되어도 테스트가 깨지지 않게  
한다는 점에서 효과가 크다. 단위 테스트의 장점은 리팩토링할 수 있도록 확신을 준다는 것이다. 단위 테스트는  
회귀를 막기 위한 안전장치다. 모의 객체를 활용해 세밀한 테스트트 하면 더 적은 테스트가 영향을 받게 되고 실패의  
원인을 정확히 찾아 주는 간명한 에러 메시지를 받을 수 있다.  
  
모의 객체는 비즈니스 로직의 일부만을 다른 부분과 격리해 테스트하는 데 적합하다. 모의 객체는 테스트 대상인  
메서드가 사용하는 객체를 대체하므로 테스트 대상 메서드는 다른 객체와 격리되는 효과가 생긴다. 그런 의미에서  
모의 객체는 스텁과 비슷하기도 하다. 그러나 모의 객체는 비즈니스 로직을 새로 구현할 필요가 없다. 모의 객체는  
테스트가 가짜로 만든 클래스의 모든 비즈니스 로직을 제어하도록 하는 껍데기일 뿐이다.  
  
스텁은 사전에 정의된 동작만 수행한다. 간단한 동작이라도 스텁의 행동은 런타임에 따라 달라지지 않는다. 반면  
모의 객체에서 사전에 정의된 동작은 없으며 대신 테스트를 실행하는 중에 모의 객체가 수행할 행동을 기대할 수  
있다. 다른 테스트를 수행할 때는 모의 객체를 새로 초기화한 다음 새로운 행동을 기대하면 된다. 모의 객체를  
활용한 테스트는 모의 객체 초기화 -> 기대 설정 -> 테스트 실행 -> 단언문 검증 순서로 진행된다.  
  
# **모의 객체를 활용해 단위 테스트하기*  
한 계좌에서 다른 계좌로 이체를 하는 간단한 유스 케이스를 생각해 보자.  
  
AccountService는 Account 객체를 처리하는 서비스 클래스다. 그리고 (예를 들어 JDBC 같은 걸 이용해서)  
AccountManager 클래스를 가지고 데이터베이스에 데이터를 영속시킨다. 우리의 관심사인 계좌 이체 서비스는  
AccountService.transfer 메서드로 구현할 수 있다. 모의 객체가 없다면 AccountService.transfer 메서드를  
테스트한다는 것은 데이터베이스를 준비하고 테스트 데이터를 사전에 밀어 넣고 (자바 EE 애플리케이션 서버 같은)  
컨테이너에 코드를 배포해야 한다는 말과 같다. 이런 프로세스는 애플리케이션이 엔드 투 엔드로 동작하는지 확인하는  
데 필요하다. 그러나 비즈니스 로직만 단위 테스트하려는 데 이 정도는 너무 과하다.  
  
계좌이체 솔루션  
account 패키지 하위  
Account, AccountManager, AccountService 참조  
  
AccountService의 transfer 메서드를 단위 테스트 한다고 생각해 보자. 그렇다면 AccountManager의 구현체가 준비될 때까지  
AccountManager에 대한 모의 객체를 구현하여 테스트를 별도로 해야 할 것이다. transfer 메서드가 해당 인터페이스를 사용하며  
격리된 상태로 테스트를 해야 하기 떄문이다.  
  
account 패키지 하위 MockAccountManager 클래스 참조  
  
# **모의 객체에 비즈니스 로직을 작성하지 않는다**  
모의 객체를 작성할 때 가장 중요한 규칙은 모의 객체가 비즈니스 로직을 가져서는 안 된다는 것이다. 모의 객체는 테스트가 시키는  
대로만 해야 한다. 다시 말해 순전히 테스트에 의해서만 구동되는 객체가 모의 객체다. 이러한 특성은 모든 로직을 가지고 있는  
스텁과 반대된다. 모의 객체에 비즈니스 로직을 넣지 않으면 좋은 점이 두 가지 있다.  
1. 모의 객체를 만들기가 쉬워진다.  
2. 모의 객체는 빈 껍데기이므로 모의 객체를 테스트할 필요가 없다.  
  
모의 객체를 사용하는 일반적인 테스트 예제  
account 패키지 -> TestAccountService 클래스 참조  
  
모의 객체가 없이 실제로 테스트를 하려면 JDBC 등을 활용해야만 했다.  
  
# **문제될 만한 것만 테스트한다**  
Account 클래스까지 모의 객체로 만들지는 않았다. 굳이 데이터 접근을 위한 객체까지 모의 객체로 만들 필요가 없기 때문이다.  
이런 객체는 환경에 크게 영향을 받지도 않고 기본적으로 매우 단순한다. 그리고 Account 객체를 사용하는 다른 클래스에 대한  
테스트가 있다면 Account 객체를 간접적으로 테스트한 것으로 간주할 수 있다. Account 클래스가 올바르게 동작하지 않는다면  
Account 객체를 사용하는 다른 테스트가 실패하고 거기서 문제가 무엇인지 알려 줄 것이다.  
  
# **모의 객체를 활용해 리팩토링하기**  
일반적으로 단위 테스트는 테스트 대상 코드에 대해 완전히 투명해야 하며 테스트를 단순하게 만들 목적으로 런타임  
코드를 변경해서는 안 된다는 통념이 있다. 그러나 이는 옳지 않다. 단위 테스트는 런타임 코드의 가장 중요한 클라이언트이며  
다른 클라이언트와 거의 비슷한 수준의 취급을 받아야 한다. 코드가 테스트하기에 충분히 유연하지 않다면 코드를  
수정하는 것은 당연하다.  
  
AccountManager 클래스 구현  
account 패키지 -> DefaultAccountManager1 클래스 참조  
  
상위 예제에는 두 가지 문제가 있다. 둘 다 코드가 충분히 유연하지 못하며 변화에 적응하기 어렵게 설계된 것과 관련이 있다.  
첫 번째 문제는 Log 객체를 바꿔서 쓸 수 없다는 것이다. Log 객체를 클래스 내부에서 생성했기 때문이다. 예를 들어 테스트를  
위해 아무 일도 하지 않는 Log 클래스를 모의하고 싶지만 그럴 수는 없다. 일반적으로 이런 클래스는 어떤 Log 객체가 주어지더라도  
그걸 사용할 수 있어야 한다. 이 클래스의 목표는 로거를 만드는 것이 아니라 JDBC 로직을 수행하는 것이다.  
  
두 번째 문제인 PropertyResourceBundle 클래스도 비슷하다. 지금 당장은 괜찮아 보일 수 있다. 그러나 만약 XML을 사용하기로  
한다면 해당하는 부분도 바뀌어야 한다.  
  
어떤 구현체를 사용할지를 결정하는 것이 이 클래스 설계의 목표가 되어서는 안 된다.  
  
훌륭한 설계 전략은 클래스 안에서 객체를 직접 생성하는 것이 아니라 비즈니스 로직과 직접 관계없는 객체를 파라미터로 전달하는  
것이다. 궁극적으로 로거나 구성 관련 컴포넌트는 여러 곳에서 사용할 수 있도록 최상위 수준으로 올라가야 한다. 이런 전략은 코드를  
유연하게 만들고 변화에 잘 적응할 수 있게 한다.  
  
# **리팩토링 예제**  
호출자가 도메인 객체를 전달할 수 있게 모든 코드를 리팩토링 하는 것은 시간이 오래 걸릴 수 있다. 그리고 단위 테스트를  
작성하기 위해 아직 애플리케이션 전체를 리팩토링할 준비가 되지 않았을 수도 있다. 다행히도 간단한 리팩토링 몇 가지만  
적용하면 인터페이스를 동일하게 유지하면서도 내부에서 생성하면 안 되는 도메인 객체를 외부에서 전달하게 수정할 수 있다.  
  
리팩토링 예제  
account 패키지 -> DefaultAccountManager2 클래스 참조  
  
# **리팩토링 시 고려 사항**  
리팩토링을 하니 테스트에서 도메인 객체를 제어할 수 있는 비밀 통로를 열어준 격이 되었다. 하위 호환성을 유지하면서도 향후  
리팩토링할 때도 도움이 되도록 길을 연 것이다. 이제는 호출 클래스가 원하는 시점에 새로운 생성자를 사용할 수도 있다.  
  
테스트를 쉽게 하려고 비밀 통로를 연다는 우려에 대해서 익스트림 프로그래밍 전문가인 론 제프리스는 다음과 같이 설명한다.  
  
내 차에는 진단기와 기름 계량봉이 있다. 용광로 옆에도 검사기가 있고 오븐에도 검사기가 있다. 내가 쓰는 만년필의 카트리지는  
잉크가 얼마나 남았는지 투명하게 보여 준다.  
클래스에 메서드를 추가하는 게 테스트를 하는 데 유용하다고 생각되면 나는 그렇게 한다. 이런 일은 인터페이스는 간단하지만  
내부 기능이 복잡할 때(즉 클래스를 추출해야 한다고 느낄 때) 가끔 일어난다.  
단지 클래스에 대해 내가 알고 있는 만큼을 제공하고 그런 다음 클래스가 원하는 것이 무엇인지 알기 위해 클래스의 행동을 주시하는  
것이다.  
  
# **실용적인 디자인 패턴: 제어의 역전**  
제어의 역전을 적용하는 것은 클래스가 직접 책임지지 않는 객체를 내부에서 생성하는 것이 아니라 외부에서 의존성을 통해 주입하는  
것을 의미한다. 이때 의존성은 생성자나 세터 메서드로 전달할 수 있고 또 다른 메서드의 파라미터로 전달할 수 있다. 의존성을  
올바르게 구성하는 것은 메서드를 호출한 곳의 책임이지 호출을 받은 곳의 책임이 아니다.  
  
제어의 역전을 잘 활용하면 단위 테스트를 쉽게 작성할 수 있다.  
  
account 패키지 -> TestDefaultAccountManager 클래스 참조  
  
위의 예제는 테스트 코드에서 테스트 대상 코드의 로깅이나 설정과 관련한 동작을 완벽하게 제어할 수 있다. 결과적으로 코드가  
유연해졌으며 다양한 로깅이나 설정을 사용할 수 있게 되었다. 현재로서는 개발자가 이러한 리팩토링으로 내부 인스턴스를 제어할  
수 없었던 문제를 해결했다.  
  
테스트를 소스 코드보다 먼저 작성했을 때 소스 코드가 더욱 유연하도록 설계했다는 점에 유의해야 한다. 단위 테스트 작성의 핵심은  
유연성이다. 테스트를 먼저 작성해야 나중에 코드를 유연하게 만들기 위해 리팩토링하는 데 비용이 많이 들지 않는다.  
  
# **HTTP 연결 모의하기**  
7장에서 스텁을 활용해 테스트 했던 예제를 이번에는 모의 객체를 사용하여 구현한다. 추가적이로 이번에는 자바 인터페이스  
(HttpURLConnection 인터페이스)를 구현하지 않고 단순 클래스에 대한 모의 객체를 생성한다.  
  
이번에는 웹 리소스에서 격리된 상태에서 getContent 메서드를 단위 테스트하는 것이 목적이다.  
  
# **모의 객체 정의하기**  
런타임에서 모의 객체를 바꿔치기 할 것이다. URL 클래스는 final 클래스이므로 MockURL 클래스가 URL 클래스를  
상속할 수 없다. 이런 기능을 다른 수준에서 모의함으로써 해결할 것이다. 모의 객체를 사용할 때 의존성 주입을  
활용하지 않는다면 실제 클래스를 모의 객체로 바꾸기 어려울 수 있다. 그리고 비밀 통로를 열어 주기 위해 코드를  
수정해야 한다는 점은 모의 객체를 부정적으로 보게 만들 소지가 있다. 그러나 코드를 유연하게 작성하도록 주의를  
환기하는 것이야말로 모의 객체를 사용해야 하는 가장 큰 이유 중 하나다.  
  
# **예제 메서드 테스트하기**  
테스트 대상  
web 패키지 -> WebClient 클래스 참조  
  
# **첫 번째 시도: 쉬운 리팩토링 기법**  
사용할 리팩토링 기법은 웹 서버에 대한 실제 HTTP 연결과 독립적으로 getContent 메서드를 테스트하는 것이다.  
url.openConnection 메서드가 모의 HttpURLConnection 객체를 반환하도록 URL 객체를 모의하는 것이다.  
MockHttpURLConnection 클래스는 테스트에서 getInputStream 메서드로 반환할 내용을 가질 수 있도록 구현한다.  
  
web 패키지 -> TestWebClientMockFail 클래스 참조  
  
위의 예제는 효과가 없다. JDK에서 기본적으로 제공하는 URL 클래스는 final 클래스이고 사용 가능한 다른 URL  
인터페이스도 없다. 그리고 확장을 위해서는 너무 많은 노력이 필요해 보인다.  
다른 방법은 모의할 다른 객체를 찾아야 한다. 한 가지 해결책은 URLStreamHandlerFactory 클래스를 스텁으로 만드는 것이다.  
이번 장은 모의 객체를 학습할 것이므로 getContent 메서드를 리팩토링 할 것이다.  
  
리팩토링 예제  
web 패키지 -> WebClient1 클래스 참조  
  
메서드 팩토리(method factory)라는 일반적인 리팩토링 방식은 모의할 클래스 인터페이스가 없을 때 특히 유용하다. 메서드 팩토리  
기법은 먼저 대상 클래스를 상속하고 이를 제어하기 위한 세터 메서드를 추가한다. 그리고 테스트를 위해 원하는 내용을 반환하기 위한  
게터 메서드를 재정의한다.
  
WebClient1 클래스를 상속하고 createHttpURLConnection 메서드를 재정의 하는 헬퍼 클래스  
헬퍼 클래스를 이용한 테스트  
web 패키지 -> TestWebClientMock 클래스 참조  
  
메서드 팩토리는 괜찮은 기법이지만 완벽하지는 않다. 테스트 대상 클래스를 서브클래싱하면 로직이 바뀐다. 그렇다면 서브클래스를  
테스트할 때는 무엇을 테스트하고 있는 것인가?  
  
이런 기법은 테스트하기 쉬운 객체를 만드는 수단으로써는 유용하다. 그러나 여기서 멈추면 우리가 테스트하고자 하는 대상과 비슷하기는  
하지만 같지는 않은 무엇인가를 테스트하는 정도에서 끝나 버린다. 코드를 변경할 수 없는 서드 파티 라이브러리에 대한 테스트를 작성하려는  
게 아니다. 테스트 대상 코드를 완벽하게 제어하며, 코드를 개선하고, 더 테스트 친화적이게 만들려는 것이다.  
  
# **두 번째 시도: 클래스 팩토리를 사용한 리팩토링**  
제어의 역전 패턴에 따르면 필요한 리소스는 getContent 메서드 또는 WebClient 클래스로 전달되어야 한다.  
그리고 앞으로 사용할 유일한 리소스는 HttpURLConnection 객체다. 그려면 WebClient.getContent 시그니처를  
다음과 같이 변경할 수 있다.  
  
public String getContent(URL url, HttpURLConnection connection)  
  
이렇게 파라미터로 HttpURLConnection 객체를 받는다는 것은 HttpURLConnection 객체 생성을 WebClient를  
호출한 쪽에 위임한다는 것을 의미한다. 그런데 HttpURLConnection 객체는 URL 클래스에서 가져와야 하므로  
시그니처가 썩 좋아 보이지는 않는다.  
  
클래스 팩토리 리팩토링 기법을 사용하여 ConnectionFactory 인터페이스를 만들고 이를 구현한 클래스의 역할은  
(HTTP, TCP/IP 등) 연결의 종류가 무엇이든 적절한 InputStream 객체를 반환하는 것이다.  
  
web 패키지 -> ConnectionFactory 인터페이스, WebClient2클래스 참조  
  
예제에서는 HTTP 연결을 맺는 것과 독립적으로 웹 콘텐츠를 가져오게 바꾸었다. 첫 번째 리팩토링 시도는 HTTP 프로토콜  
을 사용하는 URL에서만 작동하는 반면 이번 예제 리펙토링은 어떠한 표준 프로토콜(file://, http:// ftp://,  
jar:// 등) 또는 사용자 정의 프로토콜에서도 잘 작동한다.  
  
ConnectionFactory 인터페이스 구현  
web 패키지 -> HttpURLCOnnectionFactory 클래스 참조  
  
구현한 ConnectionFactory 클래스를 이용한 모의 객체 생성  
web 패키지 -> MockConnectionFactory 클래스 참조  
  
모의 객체에는 어떠한 비즈니스 로직도 들어 있지 않으며 외부에서 setData 메서드를 통해 완벽하게 제어할 수 있다.  
  
MockConnectionFactory를 사용한 테스트 예제  
web 패키지 -> TestWebClient 클래스 참조  
  
URL이 주어졌을 때 웹 콘텐츠를 반환하는 WebClient.getContent 메서드를 단위 테스트 하면서 메서드를 리펙토링하였고 변화에  
더 잘 대응할 수 있는 확장 가능한 구현으로 개선하였다.  
  
# **모의 객체를 트로이 목마로 사용하기**  
모의 객체는 트로이 목마적 속성을 갖고 있지만 그렇다고 악의적인 것은 아니다. 모의 객체는 모의 객체를 호출하는  
클래스가 인식하지 못하는 상태에서 실제 객체를 대체한다. 모의 객체는 클래스 내부 정보에 접근할 수 있으므로 매우  
강력하다.  
모의 객체를 관찰자로 사용하여 테스트 개상 객체가 호출하는 메서드를 모니터링 할 수 있다. HTTP연결 예제에의 경우  
InputStream의 close 메서드가 호출되었는지를 모니터링할 필요가 있다. 자원 누수가 발생할 수 있으므로 반드시  
스트림을 닫아야 하기 때문이다. 자원 누수는 리더, 스캐너, 버퍼같이 반드시 사용하고 난 후 메모리에서 삭제해야 하는  
자원을 삭제하지 않았을 때 발생한다. 지금까지 InputStream에서는 모의 객체를 사용하지 않았다. 그러나 verify  
메서드로 close 메서드가 호출되었는지를 쉽게 검증할 수 있다. 테스트가 끝날 때 verify 메서드를 사용하여 호출했어야  
하는 모든 메서드가 호출됐는지를 검증할 수 있다. 또한 close 메서드가 정확히 한 번 호출되었는지 검증하고 두 번  
이상 호출되었거나 한 번도 호출되지 않은 경우 예외를 던질 수도 있다. 이러한 검증을 기대라고 한다.  
  
# **기대(expectation)**  
모의 객체를 외부에서 호출하는 클래스가 정확하게 행동했는지 검증하기 위해 모의 객체에 내장된 기능. 예를 들어  
데이터베이스 커넥션을 모의한 객체는 close 메서드가 모의 객체와 관련한 테스트 중에 정확히 한 번 호출되는지  
검증할 수 있다.  
  
자원 누수를 방지하기 위해 쓰고 난 자원은 반드시 반납해야 한다는 기대를 검증하는 예제  
web 패키지 -> MockInputStream 클래스 참조  
  
MockInputStream 클래스의 close 메서드에 대한 기대는 간단하다. 항상 한 번만 호출되어야 한다는 것이다. 하지만 테스트 대상  
코드에 따라 closeCount 메서드에 대한 기대가 달라질 수 있다. 모의 객체는 보통 setExpectedCloseCalls 같은 메서드가 있으므로  
테스트가 모의 객체에게 무엇을 기대해야 하는지 알려 줄 수 있다.  
  
verify 메서드를 사용한 테스트  
web 패키지 -> TestWebClientFail1 클래스 참조  
  
이전 테스트에서 ByteArrayInputStream을 사용했다면 이번에는 MockInputStream을 사용한다. 모든 기대가 충족되었는지를 검증하기  
위해 테스트의 끝부분에 verify 메서드를 호출한다.  
  
기대는 다른 용도로도 많이 사용한다. 예를 들어 컴포넌트 매니저가 컴포넌트 생애 주기 메서드를 호출하는 경우 해당 메서드가 지정된  
순서대로 호출될 것을 기대할 수 있다. 또는 모의 객체에 적절한 값이 파라미터로 전달됐는지를 기대할 수 있다. 일반적으로 기대는   
테스트 중에 모의 객체가 우리가 원하는 방식으로 행동하는지 검증하는 것과 동시에 모의 객체를 사용한 내역에 대해 피드백을 받고자  
할 때 유용하다. 테스트는 메서드 호출 수, 메서드에 전달되는 파라미터, 메서드가 호출되는 순서에 관한 정보를 제공할 수 있다.  
  
# **모의 객체 프레임워크 사용해 보기**  
프레임워크를 잘만 사용하면 프로젝트에서 모의 객체를 더 쉽게 만들 수 있다. 가장 널리 사용하는 모의 객체 프레임워크는  
EasyMock, JMock, Mockito가 있다.  
  
# **EasyMock**  
EasyMock은 모의 객체를 사용하기 위한 유용한 클래스를 제공하는 오픈 소스 프레임워크다. EasyMock을 사용하려면  
pom.xml에 의존성을 추가해야 한다.  
  
EasyMock을 사용하여 TestAccountService 테스트를 재작업  
account 패키지 -> TestAccountServiceEasyMock 클래스 참조  
  
이번에는 WebClient의 getContent 메서드를 재작업한다. 이를 위해 해당 메서드에 대한 모든 의존성을 모의해야 한다. EasyMock  
은 인터페이스만 모의할 수 있는데 InputStream은 인터페이스가 아니라 클래스다.  
이를 해결하기 위해 EasyMock의 클래스 확장을 사용한다. EasyMock의 클래스 확장을 사용하여 클래스나 인터페이스에 대한 모의 객체를  
생성할 수 있다.  
  
EasyMock을 활용하여 WebClient 테스트를 재작업  
web 패키지 -> TesetWebClientEasyMock 클래스 참조  
  
EasyMock을 사용하기는 매우 쉬우므로 프로젝트에 사용하는 것을 충분히 고려할 만하다.  
  
# **JUnit 모범 사례: EasyMock으로 모의 객체 생성하기**  
EasyMock의 API를 확인해 보면 createMock 메서드에 다양한 시그니처가 있는 것을 알 수 있다. 보통 다음과 같은 시그니처 사용을  
추천한다.  
  
createMock(String name, Class claz);  
  
찾아보면 다음과 같은 스타일도 있다.  
  
createMock(Class claz);  
  
createMock(Class claz)를 사용하면 오류 메세지에 이름이 나오지 않는다.  
  
# **JMock**  
JMock으로 작업하기 위해서는 pom.xml에 의존성을 추가해야 한다.  
  
JMock을 사용하여 TestAccountService 테스트를 재작업  
account 패키지 -> TestAccountServiceJMock 클래스 참조  
  
EasyMock은 호출 횟수를 검증하기 위해 verify메서드를 호출해야 했다. JMock을 사용하면 그렇게 할 필요가 없다. JMock 확장이 이 작업을 대신  
처리하며 만약 메서드를 기대한 만큼 호출하지 않으면 테스트가 실패한다.  
  
JMock을 사용하여 TestWebClient 테스트를 재작업  
web 패키지 -> TestWebClientJMock 클래스 참조  
  
JMock은 EasyMock 만큼 사용하기 쉽다. EasyMock과 비교하면 JMock은 JUnit5와 더 잘 통합되어 있다. 프로그래밍 방식으로 context필드를  
정의할 수도 있다.  

