# **JUnit5를 사용한 BDD**  
TDD는 단위 테스트를 사용하여 코드를 검증하는 놀라운 방법론이다. TDD의 이점은 명확하다. 그러나 TDD의 개발 주기는 개발자가 애플리케이션의  
비즈니스 목표에 관한 전체적인 그림을 놓칠 수 있게 한다. TDD는 다음과 같은 개발 주기를 따른다.  
  
테스트한다. 코드를 작성한다, 리팩토링한다, (반복한다)  
  
프로젝트가 더 커지고 복잡해지고 단위 테스트의 수가 늘어나면 테스트를 이해하고 유지하기가 더 어려워질 것이다. 또한 테스트와 소스 코드 간에  
밀접하게 결합되어 버릴 수도 있다. 테스트의 단위(클래스 또는 메서드)에만 초점을 둔다면 비즈니스 목표는 쉽게 간과될 수 있다.  
  
이를 해결하기 위해 TDD를 기반으로 한 BDD(behavior-driven development, 행위 주도 개발)이라는 새로운 기법이 대두되었다. BDD는  
테스트보다는 기능 자체에 중점을 두고 기능이 예상대로 동작하는지 확인한다.  
  
# **BDD 살펴보기**  
행위 주도 개발의 개념은 댄 노스가 2000년대 중반에 창안했다. BDD란 비즈니스 요구 사항과 목표를 소프트웨어의 동작과 기능으로 변환하는 개발  
방법론을 말한다. BDD를 실천한다면 애플리케이션이 어떻게 동작해야 하는지 구체적인 사례를 가지고 여러 팀 간에 원할하게 소통할 수 있으며  
이해관계자 간의 협럭을 장려함으로써 의미 있는 소프트웨어를 만들 수 있게 된다. TDD가 제대로 동작하는 소프트웨어를 만드는 데 도움이 된다면  
BDD는 비즈니스적 가치를 제공하는 소프트웨어를 만드는 데 도움이 된다. BDD를 실천함으로써 실제로 조직에 필요한 기능이 무엇인지 정확하게  
이해할 수 있고 그 기능에 집중하여 개발할 수 있다. 또한 사용자가 요구하는 것을 넘어서 사용자가 실제로 필요로 하는 것이 무엇인지도 이해할 수  
있게 된다.  
  
때로는 사람들 사이의 의사소통에서 문제와 오해가 발생할 수 있다. 보통 의사소통은 다음과 같은 흐름으로 진행된다.  
1. 고객이 비즈니스 분석가에게 기능에 대해 이해한 바를 말한다.  
2. 비즈니스 분석가는 소프트웨어가 어떻게 동작해야 하는지 설명하면서 개발자에게 요구 사항을 전달한다.  
3. 개발자는 요구 사항에 따라 코드를 작성하고 신규 기능을 구현하기 위한 단위 테스트를 작성한다.  
4. 테스터는 요구 사항을 기반으로 테스트 케이스를 만들고 신규 기능이 동작하는지 검증한다.  
  
그런데 이 과정에서 중요한 정보가 잘못되었거나, 왜곡되었거나, 심지어 누락될 수 있다. 그 결과 기능은 고객이 처음에 생각했던 것과 완전히  
달라질 수도 있다.  
  
# **신규 기능 추가하기**  
비즈니스 분석가는 비즈니스 목표를 달성하는 소프트웨어 기능을 만들기 위해 고객과 소통한다. 이러한 기능은 여행자가 목적지까지 가는 가장 짧은  
방법을 알려주기나 여행자가 목적지까지 가는 가장 저렴한 방법을 알려 주기와 같은 일반적인 요구 사항으로 표현될 수 있다.  
  
이런 기능은 스토리로 만들어진다. 스토리는 출발지와 목적지 간에 최소환승 경로 찾기 또는 출발지와 목적지 간에 최단 경로 찾기 등으로 표현할 수  
있다.  
  
스토리는 구체적인 사례를 가지고 정의할 수 있다. 이러한 사례는 스토리의 인수 기준(acceptance criteria)이 된다. 인수 기준은 Given, When,  
Then 키워드를 사용해 BDD 스타일로 표현할 수 있다.  
  
예시  
Given 어떤 회사에서 운항하는 항공편을 대상으로  
When 5월 15일부터 5월 20일까지 부쿠레슈티에서 뉴욕으로 가는 가장 빠른 항공편을 찾고자 할 때  
Then 부쿠레슈티-프랑크푸르트-뉴욕을 잇는 경로가 최단 경로이며 소요 시간은...  
  
# **요구 사항 분석에서 인수 기준까지**  
항공편 관리 시스템의 일반적인 비즈니스 목표라면 전반적으로 질 좋은 항공 서비스를 제공하여 매출을 늘리는 것 정도가 될 수 있을 것이다. 그러나  
이런 목표는 너무 범용적이므로 여기서는 다음과 같이 요구 사항을 구체화할 수 있다.  
  
- 항공편을 선택할 수 있는 대화형 애플리케이션을 제공한다.  
- 항공편을 변경할 수 있는 대화형 애플리케이션을 제공한다.  
- 출발지와 목적지 사이의 최단 경로를 찾아주는 대화형 애플리케이션을 제공한다.  
  
고객을 만족시키기 위해서는 요구 사항을 분석해서 만든 기능이 고객의 비즈니스 목표를 달성하거나 비즈니스적 가치를 제공해야 한다. 이때 초기  
요구 사항은 더욱 자세하게 설명해야 하는데 다음과 같이 표현할 수 있을 것이다.  
  
승객으로서  
주어진 시간 내에 해당 목적지로 갈 수 있는 항공편을 알고 싶다.  
그래서 적절한 항공편을 선택할 수 있어야 한다.  
  
또는  
  
승객으로서  
처음에 선택한 항공편을 다른 항공편으로 바꾸고 싶다.  
그래서 변경된 일정에 대응할 수 있어야 한다.  
  
적절한 항공편을 선택할 수 있어야 한다와 같은 기능은 한 번에 구현하기에는 너무 클 수 있으므로 잘게 나누는 것이 좋다. 기능을 구현해 나가는  
과정에서 주요 이정표를 통과하며 피드백을 받을 수도 있기 때문이다.  
  
앞에서 제시한 기능을 작은 스토리로 분리  

(존재한다면) 적절한 직항편을 찾는다.  
적절한 경유지가 있는 대체 항공편을 찾는다.  
적절한 편도 항공편을 찾는다.  
적절한 왕복 항공편을 찾는다.  
  
일반적으로는 특정 사례를 활용해 인수 기준을 정한다. 인수 기준은 이해관계자가 애플리케이션이 예상대로 작동한다는 데 동의할 수 있는 기준을  
나타낸다.  
  
BDD에서는 인수 기준을 Given, When, Then 키워드릴 이용하여 정의한다.  
  
Given 주어진 상황에서  
When 특정 사건이 일어났을 때  
Then 기대하는 결과  
  
다음은 인수 기준의 구체적인 사례이다.  
  
Given 특정 회사에서 운항하는 항공편을 대상으로  
When 다음 주 수요일에 부쿠레슈티에서 런던으로 여행을 갈 때  
Then 가능한 항공편은 10:35분 출발과 16:20분 출발 2개가 있다  
  
# **BDD의 이점과 과제**  
BDD 접근 방식의 이점은 다음과 같다.  
- 사용자 요구 충족: 사용자는 구현에 신경을 덜 쓰고 애플리케이션의 기능에 더 집중할 수 있다. BDD를 실천한다는 것은 본질적인 요구  
사항을 해결하는 데 가까워진다는 말과 같다.  
- 명확성 제공: 시나리오는 소프트웨어가 수행해야 하는 작업을 명확히 한다. 시나이로는 기술에 친숙한 사람과 기술에 친숙하지 못한 사람 모두  
이해할 수 있는 간단한 언어로 기술한다. 시나리오는 분할하거나 다른 시나리오를 추가하는 방식으로 모호성을 없앨 수 있다.  
- 변경 대응: 시나리오는 소프트웨어 문서의 일부다. 애플리케이션과 함께 발전하는 살아 있는 문서인 것이다. 또한 새 변경 사항을 확인하는 데에도  
도움이 된다. 자동화된 인수 테스트는 변경이 생겼을 때 시스템이 회귀하는 것을 막는다.  
- 자동화 지원: 시나리오의 단계가 이미 정의되어 있으므로 시나리오를 자동화된 테스트로 변환할 수 있다.  
- 비즈니스 가치에 집중: BDD는 프로젝트에 쓸데없는 기능이 추가되는 것을 막는다. 기능의 우선순위를 정하는 데에도 사용할 수 있다.  
- 비용 절감: 기능의 중요도에 따라 우선순위를 정하고 불필요한 기능을 만들지 않는다면 리소스가 낭비되는 일도 없을뿐더러 꼭 필요한 작업에만  
리소스를 집중할 수 있다.  
  
BDD에는 과제도 있다. BDD는 많은 참여, 강력한 협업, 상호작용, 직접적인 의사소통, 지속적인 피드백 등을 필요로 한다. 이는 몇몇 사람에게는  
부담이 될 수도 있고 인력이 세계 각지에 분산된 오늘날의 글로벌 환경에서는 외국어 능력이나 시차관리가 필요할 수도 있다.  
  
# **Cucumber와 JUnit5를 사용하여 BDD 실천하기**  
이전장에서는 TDD를 실천하면서 항공편 관리 시스템을 개발했다. 게다가 승객이 항공편에 한 번만 추가될 수 있다는 요구 사항도 구현했다.  
애플리케이션의 기능은 테스트를 통해 빠르게 검증할 수 있었다.  
  
사실 이전 장에서 실제적인 사례를 가지고 BDD가 무엇인지 체험해 본 것이다. Given, When, Then 키워드를 사용하여 테스트를 표현했고  
애플리케이션이 어떻게 동작하는지 쉽게 이해할 수 있었다.  
  
# **Cucumber 살펴보기**  
Cucumber는 BDD 테스트 프레임워크다. Cucumber는 Gherkin(걸킨)이라는 언어를 사용하여 시나리오를 일반적인 자연어로 기술한다. Cucumber는  
이해관계자들이 읽고 이해하기 쉬울뿐더러 자동화를 가능하게 해 준다.  
  
Cucumber의 주요 특징은 다음과 같다.  
- 시나리오나 구체적인 예시를 사용하여 요구 사항을 기술한다.  
- 시나리오는 Cucumber가 실행할 일련의 스탭(step)으로 정의할 수 있다.  
- Cucumber는 시나리오에 해당하는 코드를 실행하고 스프트웨어가 이러한 요구 사항을 잘 따르는지 검증한다. 그 다음 각 시나리오의 성공 또는  
실패를 기술한 리포트를 생성한다.  
  
Gherkin의 주요 특징은 다음과 같다.  
- Gherkin은 Cucumber가 일반적인 자연어 텍스트를 이해할 수 있도록 하는 간단한 문법 규칙을 정의한다.  
- Gherkin은 시스템의 동작을 문서화한다. 이때 시나리오를 통해 현재 작동하고 있는 명세를 제공하므로 요구 사항은 항상 최신 상태를 유지하게  
된다.  
  
Cucumber는 기술 이해도가 높은 사람과 이해도가 높지 않은 사람 모두 인수 테스트를 쉽게 읽고, 쓰고, 이해할 수 있게 해 준다. Cucumber를  
사용하면 인수 테스트는 프로젝트 이해관계자 간의 의사소통 도구가 될 수 있다.  
  
Cucumber로 만든 인수 테스트의 사례  
  
Given 이코노미 항공편에서  
When 일반 승객은  
Then 이코노미 항공편에 추가가 가능하고 삭제도 가능하다  
  
시나리오를 기술하기 위해 사용한 Given, When, Then 키워드는 JUnit5와 관련된 이전 작업에서도 사용했다. 그러나 이제는 Given, When, Then  
을 단순히 레이블 작성에만 사용하지 않는다. Cucumber는 Given, When, Then으로 시작하는 문장을 해석하여 @Given, @When, @Then  
어노테이션이 달린 메서드를 자동으로 생성할 수 있다.  
  
인수 테스트는 Cucumber 기능 파일로 정의한다. 기능 파일(feature file)은 Cucumber 테스트의 진입점 역할을 한다. 기능 파일에서는 Gherkin  
으로 테스트를 기술한다. 기능 파일에는 하나 이상의 시나리오가 포함될 수 있다.  
  
pom.xml에 Cucumber 의존성 추가  
  
# **TDD로 만든 기능 Cucumber로 옮기기**  
src/test/resources/features 폴더 생성  
그 안에 passengers_policy.feature 파일 생성  
  
개발자는 애플리케이션이 수행해야 하는 작업에 관한 간단한 설명과 함께 승객 정책이라는 기능을 추가한다. 그 다음 Gherkin 구문을 따라  
시나리오를 작성한다.  

passengers_policy.feature 파일 참조  
  
기능 파일에서 Feature, Scenario, Given, When, Then, And 키워드가 굵게 표시되어 있다. 기능 파일을 마우스 오른쪽으로 클릭하면 직접  
실행할 수 있도록 옵션이 나타난다.  
  
기능 파일을 실행하기 위해서는 사전에 두 가지 준비가 필요하다.  
첫째, 적절한 플러그인을 설치해야 한다. 만약 IntelliJ IDEA를 쓰고 있다면 File -> Setting -> Plugins로 들어가서 Cucumber for Java  
플러그인과 Gherkin 플러그인을 설치한다.  
  
둘째, 기능 파일이 실행되는 환경을 구성해야 한다. Run -> Edit Configuration -> Cucumber Java 으로 이동하여 다음 옵션을 입력한다.    
- Main class: cucumber.api.cli.Main  
- Glue(현재 스탭 정의가 저장되는 패키지 경로): 프로젝트 경로.airport  
- Feature or folder path: 새로 추가한 src/test/resources/features 폴더  
- Working directory: 프로젝트 폴더  
  
기능 파일을 실행하면 Cucumber 테스트 스켈레톤이 만들어진다. (하단 콘솔에 RUN 메뉴)  
  
개발자는 src/test/java 폴더에 새로운 자바 클래스를 생성하기 위해 airport 패키지를 만든다. 새로 생성할 클래스의 이름은 PassengerPolicy  
이며 처음에는 테스트 스켈레톤을 포함한다. 테스트는 passengers_policy.feature 파일에 기술한 시나리오를 따라 실행된다. 예를 들어 다음과  
같은 스텝을 실행한다고 하자.  
  
Given 이코노미 항공편에서  
  
그려면 프로그램은 @Given 어노테이션이 달린 메서드를 실행할 것이다.  
  
@Given("^이코노미 항공편에서$")  
  
airport 패키지 -> PassengerPolicy 클래스 참조  
  
개발자는 사전에 정의된 스텝의 비즈니스 로직을 테스트로 변환한다.  
  
airport 패키지 -> PassengerPolicy 클래스 참조  
  
Cucumber 테스트를 실행하기 위해서는 특별한 클래스가 필요하다. 클래스 이름은 무엇이든지 상관없다.  
  
airport 패지키 -> CucumberTest 클래스 참조  
  
테스트를 실행해보면 Cucumber로 옮기기 전에 있었던 테스트가 Cucumber로 옮기고 나서도 문제없이 유지되고 있음을 확인할 수 있다.  
  
그 외에도 테스트를 Cucumber로 옮기면 또 다른 이점이 있다. Cucumber를 사용하면 Cucumber를 사용하지 않은 테스트 클래스보다 코드 줄 수가  
줄어들지만 테스트 커버리지는 둘 다 동일하게 100%이다.  
  
AirportTest 파일에는 세 가지 계층의 일곱 가지 클래스가 포함되어 있다. 제일 위에 AirportTest 클래스가 있고 그 아래에는  
EconomyFlightTest, BusinessFlightTest 클래스가 있다. 각 항공편 테스트 클래스마다 RegularPassenger 클래스와 VipPassenger 클래스가  
있었다. 코드의 중복이 존재하는 것이다. 사실 JUnit5만 사용 가능할 떄는 테스트의 계층을 나누는 것만이 대안이었다. 반면 Cucumber를 사용하면  
각 스텝은 정확히 한 번씩만 구현하면 된다. 즉 여러 시나리오에서 동일한 스텝을 재사용하여 코드 중복을 줄일 수 있다.  
  
# **Cucumber를 활용하여 신규 기능 추가하기**  
개발자는 승객에게 제공하는 보너스 포인트와 관련한 추가 기능 명세를 받았다. 보너스 포인트를 계산하기 위해서는 각 승객이 이동한 거리를  
고려해야 한다. 보너스 포인트는 승객이 이동한 모든 항고편의 마일리지를 합산해서 계산하며 승객의 유형에 따라 계사식이 달라진다. VIP 승객의  
경우 10, 일반 승객의 경우 20으로 마일리지를 나눈 값이 보너스 포인트가 된다.  
  
개발자는 BDD를 실천하며 시나리오를 정의하고 테스트를 만들고 소스 코드를 구현하고자 한다. 물론 만들어진 테스트는 맨 처음에 실패할 것이다.  
보너스 포인트와 관련한 비즈니스 로직을 구현한 다음에 테스트를 실행하면 테스트가 통과될 것이다.  
  
resources -> features -> bonus_policy.feature 파일 참조  
  
Scenario Outline을 사용하면 스텝을 정의할 때 값을 굳이 하드코딩할 필요가 없다.  
각 스텝에서는 값을 하드코딩하지 않고 Examples와 <mileage1>, <pointes>등의 파라미터를 사용한다.  
입력 값은 Scenario Outline의 Examples에 따로 정의해 둔다. 첫 번째 표의 1행은 세 개의 마일리지 값을 나타낸다. 세 숫자를 모두 더한 다음  
(일반 승객의 경우) 20으로 나눈 값인 64가 보너스 포인트가 된다. Examples를 사용하면 JUnit5의 파라미터를 사용한 테스트를 대체할 수 있다.  
값이 시나리오에 기록되어 있으므로 누구든지 쉽게 이해할 수 있다.  
  
기능 파일을 실행하려면 저번과 같이 Run -> Edit Configuration을 맞제 작성해야 한다.  
  
실행해서 나온 스켈레톤을 가지고 BonusPolicy 클래스를 생성한다. 이 테스트를 실행하면 bonus_policy.feature 파일에 기술된 시나리오를  
따르게 된다.  
  
phase3 패키지 -> airport 패키지 -> BonusPolicy 클래스 참조  
  
개발자는 Mileage 클래스를 생성하여 필드와 메서드를 선언했지만 구현하지는 않는다. 개발자는 Mileage 클래스를 사용한 테스트가 처음에 실패하게  
만든 다음 Mileage 클래스를 구현하고 테스트를 통과시킬 것이다.  

phase3 패키지 -> mileage 패키지 -> Mileage 클래스 참조  
  
이제 개발자는 이 기능의 비즈니스 로직을 따르기 위해 BonusPolicy 클래스에서 테스트를 작성한다.  

phase3 패키지 -> airport 패키지 -> BonusPolicy 클래스 참조  
  
테스트를 진행하면 실패한다. Mileage 클래스에서 비즈니스 로직을 구현한다.  
phase3 패키지 -> mileage 패키지 -> Mileage 클래스 참조  
  
CucumberTest를 이용한 보너스 포인트 테스트를 수행하면 초록색 완료 포시를 확인할 수 있다.  
  
# **JBehave와 JUnit5를 사용하여 BDD실천하기**  
BDD 프레임워크는 여러 가지가 있다. 이번에는 JBehave를 사용한다.  
  
# **JBehave 살펴보기**  
JBehave는 프로젝트와 관련된 모든 사람이 이해할 수 있는 일반적인 자연어로 스토리를 작성할 수 있는 BDD 프레임워크다. JBehave는 스토리 파일을  
가지고 원하는 행동을 나타내는 시나리오를 정의할 수 있다.  
  
다른 BDD 프레임워크와 마찬가지로 JBehave 역시 고유한 용어를 가지고 있다.  
- 스토리: 하나 이상의 시나리오를 포함하며 자동으로 실행할 수 있는 비즈니스 동작을 나타낸다.  
- 시나리오: 애플리케이션과 상호작용하는 실제 상황을 말한다.  
- 스텝: 전통적인 BDD 개념어인 Given, When, Then을 사용하여 정의한다.  
  
# **TDD로 만든 기능을 JBehave로 옮기기**  
pom.xml파일에 JBehave 의존성 추가  
  
IntelliJ IDEA에서 JBehave를 개발하기 위한 플러그인을 설치한다.  
File -> Settings -> Plugins -> Browse Repositories로 이동하여 JBehave를 입력한다.  
JBehave Step Generator와 JBehave Support 플러그인을 설치한다.  
  
src/test/resources/airport 폴더를 만들고 passengers_policy_story.story 파일을 만들어 스토리 파일을 생성한다.  
PassengersPolicy 클래스도 생성한다.  
  
phase4 패키지 -> airport 패키지 -> PassengersPolicy 클래스  
  
스토리 파일은 해당 스토리에 대한 메타 정보를 나타내는 Meta, 무엇을 의도하는지 알려 주는 Narrative, 시나리오를 알려 주는 Scenario로 구성되어  
있다.  

passengers_policy_story.story 파일 참조  
  


  


