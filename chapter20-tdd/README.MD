# **JUnit5를 사용한 TDD**  
TDD란 개발 속도를 비약적으로 향상시키고 개발자들을 디버깅 지옥에서 벗어날 수 있게 해 주는 기법이다.  
  
# **TDD의 핵심 개념**  
TDD란 요구 사항을 테스트로 뽑아 낸 다음 테스트를 통과하는 프로그램을 개발하는 과정을 되도록 짧게 반복하는 프로그래밍 기법이다.  
1. 코드를 작성하기 전에 실패하는 테스트를 작성한다.  
2. 테스트를 통과할 수 있는 가장 단순한 코드를 작성한다.  
  
이러한 개발 방법론은 켄트 벡이 창한했다. TDD는 작동하는 클린 코드를 추구함으로써 단순한 설계를 유도하고 소프트웨어의 안정성을 제고한다.  
  
이는 요구 사항을 충족하는지 검증하지 않고도 코드를 추가할 수 있었던 기존의 소프트웨어 개발 방식과 다르다. 통념에 따르면 프로그램 개발이란 코드를  
작성한 다음, 실행이 잘되는지 하나씩 따져가며 테스트하는 것을 의미했다. 그래서 관행적인 개발 주기는 다음과 같이 나타낼 수 있었다.  
  
코드를 작성한다, 테스트한다, (반복한다)  
  
그러나 TDD는 개발 주기를 놀랍게 뒤집는다.  
  
테스트한다, 코드를 작성한다, (반복한다)  
  
즉 TDD 안에서 테스트는 설계를 주도하고 테스트 대상 메서드의 첫 번째 클라이언트가 되는 것이다.  
  
TDD의 장점은 다음과 같다.  
- 분명한 목표를 가지고 코드를 짤 수 있을뿐더러 애플리케이션이 해야 하는 일만 정확하게 개발할 수 있다.  
- 기존의 소스 코드에 버그가 생기는 것은 막아 주면서 새로운 기능을 빠르게 개발할 수 있다. 테스트는 해야 할 일만 정확하게 하는 코드를 구현하도록  
유도하는 힘이 있다.  
- 테스트는 애플리케이션의 설계 명세로 기능한다. 개발자는 테스트를 통해 해결해야 하는 과제가 무엇인지 이해할 수 있다.  
  
TDD는 사실 개발 주기가 하나 더 있다.  
  
테스트한다, 코드를 작성한다, 리팩토링한다, (반복한다)  
  
리팩토링은 소스 코드의 외부 동작에는 영향을 주지 않고 내부 구조만을 개선하는 방식으로 소프트웨어를 수정하는 작업이다. 이때 외부 동작에 영향을 주지  
않는다는 것을 증명하기 위해서 테스트를 사용할 수 있다.  
  
애플리케이션에 신규 기능을 추가하기 위한 명세를 받았을 때는 소스 코드를 작성하기 전에 먼저 명세부터 이해해야 한다. 이때 개발자가 무엇을 해야  
하는지 보여 주는 테스트를 먼저 구현한 다음 어떻게 해야 하는지를 구현한다면 어떨까? 이것이 바로 TDD의 핵심 원칙 중 하나다.  
  
잘 작성된 단위 테스트는 소스 코드를 직접 호출하는 등 실제 기능에 대한 구체적인 명세 역할을 하는데 결론적으로 TDD는 애플리케이션 기술 문서를  
작성할 때 큰 도움이 된다.  
  
# **항공편 관리 시스템**  
TDD 방식으로 개발하지 않은 항공편 관리 시스템이 있다고 가정한다.  
개발자는 먼저 시스템을 분석하고 이 시스템에 기대되는 행동이 정확하게 구현되어 있는지 확인한다. 즉 기존의 소스 코드를 모두 단위 테스트로 커버해야  
한다. 테스트를 마쳐도 또 다른 작업이 필요하다. 시스템에 대해 처음 이해한 대로 새 기능을 간단하게 추가해 본 다음, 실패하는 테스트 코드를 짜고  
마지막으로 테스트를 통과할 수 있는 코드를 작성하는 것이다.  
  
TDD 적용 전  
before 패키지  
Passenger, Flight 클래스 참조    
  
이 로직에는 아직까지 테스트 코드가 없다. 맨 처음 이 로직을 구현한 개발자는 단순히 로직을 돌려 보고 기대한 결과와 직접 비교하는 것으로 테스트를  
갈음했을 것이다.예를 들자면 Airport 클래스를 만들어 그 안에 클라이언트 역할을 수행할 main 메서드를 만들고 여러 항공편과 승객의 경우의 수를  
만들어 테스트를 했을 것이다.  
  
before 패키지  
Airport 클래스 참조  
  
# **항공편 관리 시스템을 TDD로 개발하기 위한 사전 준비**  
pom.xml에 JUnit5 의존성 추가  
이코노미 항공편에 대한 로직을 검증하기 위해 JUnit5의 중첩 테스트를 사용한다. 이코노미 항공편과 비즈니스 항공편이 각각 유형 분류가 되어 있으므로  
테스트를 그룹으로 묶을 수 있는 것처럼 보이기 때문이다.  
  
phase1 패키지 -> AirportTest 클래스 참조  
  
TDD를 실천해 보고 싶다면 먼저 시스템의 기존 코드에 대한 테스트를 만들어야 한다.  
테스트를 진행하고 테스트 커버리지를 확인하면 Passenger 클래스와 Flight 클래스의 클라이언트 역할을 했던 Airport 클래스는 테스트가 되지 않았다.  
테스트가 클라이언트 역할을 하므로 Airport 클래스는 필요가 없어진 것이다. 게다가 코드 커버리지도 100%를 달성하지 못했다. 테스트 코드가 실행되는  
동안 getFlightType 메서드는 한 번도 사용되지 않았으며 항공편이 이코노미도 비즈니스도 아닌 경우(switch 문에서 default 절에 해당할 때)는  
커버되지 않는다. 이는 개발자가 불필요한 소스 코드를 정리하기 위해 리팩토링을 해야 한다는 점을 시사한다. 이때 개발자는 소스 코드를 자신 있게  
리팩토링할 수 있다. 시스템이 테스트로 커버되고 있기 떄문이다. TDD를 실천하면 시간이 지날수록 코드를 수정할 때 확신이 생긴다.  
  
# **항공편 관리 시스템 리팩토링하기**  
개발자는 소스 코드가 flightType 필드와 관련한다는 것을 알고 있다. 사실 switch 문에서 default 절에 해당하는 경우는 절대로 일어나지 않는다.  
항공편의 종류는 이코노미 혹은 비즈니스로 의사 결정되어 있으므로 이는 자명하다. 그러나 default 절을 삭제하면 소스가 컴파일되지 않는다.  
  
리팩토링의 핵심은 절차적인 스타일의 분기문 대신 다형성(polymorphism)을 적용해 설계를 바꾸는 것이다. 다형성은 하나의 객체가 여러 가지 IS-A  
관계를 가질 수 있다는 의미로 다형성을 적절하게 활용하면 컴파일 타임이 아니라 런타임에서 적절한 타입에 맞는 메서드를 호출할 수 있다.  
  
여기에는 개방-폐쇄의 원칙(확장에는 열려있고 변경에는 닫혀 있어야 한다. open-closed principle)이 적용되어 있다. 기존의 코드는 새로운 항공편  
유형이 추가될 때마다 소스 코드를 수정해야 한다. 항공편 유형이 추가될 때마다 분기문이 늘어날 것이다. 또한 flightType에 반드시 의존할 수밖에 없고  
실행될 일이 없는 default 절을 반드시 가지고 있어야 하는 문제가 있다.  
  
다형성을 활용해서 길게 늘어질 수 있는 분기문을 리팩토링하면 flightType과 switch 문의 default 절은 더는 필요가 없다. 새로운 항공편 종류를  
추가하기도 쉽다. 개방-폐쇄의 원칙에 따르면 이러한 설계는 확장에는 열려 있으면서(새 클래스를 추가하기는 쉽고) 수정에는 닫혀 있다.(기존에 정의한  
Flight 클래스는 수정이 되어서는 안 된다)  
  
물론 개발자는 자문할 수 있다. 외부 동작에 영향을 주지 않게끔 리팩토링을 아주 잘하고 있다는 것을 어떻게 알 수 있을까? 답은 테스트가 알려 준다.  
테스트를 통과한 다는 것은 기존 기능이 변경되지 않았음을 보장해 주기 때문이다. TDD의 강점은 여기에서 발휘된다.  
  
다형성의 설계의 기초가 되는 추상 클래스  
phase2 패키지 -> Flight 추상 클래스 참조  
  
추상 클래스 Flight를 상속한 클래스  
phase2 패키지 -> EconomyFlight, BusinessFlight 클래스 참조  
  
AirportTest 리팩토링, Airpot 클래스 삭제  
  
테스트를 수행하면 코드 커버리지가 100%가 나온다. TDD를 실천하며 시스템을 리팩토링하는 것은 코드의 품질을 제고함과 동시에 코드 커버리지를 높이는  
데에도 효과적이다.  
  
# **TDD로 신규 기능 추가하기**  
# **프리미엄 항공편 추가하기**  
돈 로버츠가 말한 3의 법칙  
어떤 작업을 처음 할 때는 그냥 한다. 두 번째에는 반복 작업에 왠지 모르게 움찔하겠지만 같은 작업을 그대로 할 것이다. 세 번째 작업에 이르러서야  
비로소 리팩토링을 한다. 즉, 스트라이크 세 번이면 리팩토링을 하는 것이다.  
  
기존의 테스트를 리팩토링한 AirportTest 클래스  
phase3 패키지 -> AirportTest 클래스 참조  
  
개발자는 기존 테스트를 리팩토링하여 TDD를 더 쉽게 적용할 수 있도록 했다. 지금 테스트를 한다면 소스 코드의 작동 방식과 비즈니스 로직을 더  
쉽게 이해할 수 있을 것이다. (테스트 코드를 구동하면 Given-When-Then 구조로 출력된다)  
  
개발자는 프리미엄 항공편의 기능을 구현한다. 그리고 addPassenger와 removePassenger 메서드를 재정의한다. 지금은 이 메서드가 (마치   
스텁처럼) 아무 비즈니스 로직 없이 단순히 false를 반환한다. 해당 메서드의 비즈니스 로직은 테스트를 만든 다음에 작성할 것이다. TDD를  
실천한다는 것은 먼저 테스트를 작성한 다음에 테스트를 통과하는 소스 코드를 짜는 것이기 떄문이다.  
  
phase4 패키지 -> PremiumFlight 클래스 참조  
AirportTest 클래스에 PremiumFlight 테스트 추가  
  
테스트 코드를 실행하면 일부 테스트 코드가 실패한다. 사실 일부 테스트 코드가 실패했다는 점은 큰 문제가 되지 않는다. 오히려 이미 알고 있었던  
것이다. TDD를 실천한다는 것은 문자 그대로 테스트가 개발을 주도한다는 것을 의미하므로 개발자는 먼저 실패하는 테스트를 만든 다음에 테스트를  
통과할 수 있는 소스 코드를 작성하는 것이 옳다. 그런데 여기에 놀라운 사실이 있다. 아무것도 하지 않았는데도 프리미엄 항공편에서 일반 승객에  
대한 테스트에 이미 테스트 통과 표시가 떴다. 이는 즉 비즈니스 로직(단순히 false를 반환하는 addPassenger와 removePassenger 메서드)으로도  
충분하다는 뜻이다. 개발자는 VIP 승객에 관한 비즈니스 로직에만 집중하면 된다. 켄트백은 TDD는 적시에, 적환한 문제에 주의를 기울일 수 있게  
해준다. 그래서 더욱 깔끔하게 설계하고 미세하게 다듬어 나갈 수 있게 도와준다. TDD는 시간이 지날수록 코드에 대한 확신을 얻게 한다. 라고  
말했다.  
  
개발자는 PremiumFlight 클래스로 돌아가서 VIP 승객에 관한 비즈니스 로직에 집중한다. 테스트 주도 아래 개발자는 문제를 직시할 수 있었다.  
  
phase4 패키지 -> PremiumFlight 클래스 참조  
  
테스트를 실행하면 결과적으로 모든 것이 순조로이 진행된다. 물론 테스트가 개발자로 하여금 테스트를 통과하는 코드를 작성하도록 주도한 것이다.  
코드 커버리지도 100%를 달성했다.  
  


  



  

