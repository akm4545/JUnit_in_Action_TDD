# **컨테이너를 활용한 테스트**  
  
# **일반적인 단위 테스트의 한계**  
HttpServlet의 isAuthenticated 메서드를 구현하는 예제  
servlet 패키지 -> SampleServlet 클래스 참조  
  
서블릿이란 웹 애플리케이션 서버에서 동작하는 자바 클래스를 말한다. 사용자 정보가 올바른지를 확인할 수 있는 인증 메커니즘이 필요한데 사용자  
인증이 되었는지를 검증하는 메서드로 isAutehnticated 메서드를 사용하며 테스트하는 상황이라고 가정한다.  
  
해당 서블릿 예제는 일반적인 단위 테스트의 문제가 무엇인지 보여 준다. 만약 isAuthenticated 메서드를 테스트하려면 사전에 유효한  
HttpServletRequest 객체를 가지고 있어야 한다. 그런데 HttpServletRequest는 인터페이스이므로 new 예약어를 사용해서 HttpServletRequest를  
생성할 수가 없다. 게다가 HttpServletRequest 객체의 생애 주기나 구현은 컨테이너(이 경우 서블릿 컨테이너)에서 제공하는 것이지 개발자가 하는  
것이 아니다. HttpSession도 역시 마찬가지다. 즉 JUnit만으로는 isAuthenticated 메서드와 일반적인 서블릿에 관한 테스트를 작성하기가  
어렵다.  
  
서블릿이나 JSP에서 컨테니어는 Tomcat이나 Jetty 같은 서블릿 컨테이너를 말한다. 그 외에는 EJB(Enterprise Java Beans) 컨테이너인 JBoss등이  
있다.(JBoss는 WildFly로 이름이 변경되었다.) 이러한 컨테이너에서 자바 코드는 기본적으로 잘 동작한다. 그러나 컨테이너가 런타임에  
HttpServletRequest 같은 객체를 생성하고 관리하는 한 일반적인 JUnit만으로는(JUnit5 기능을 쓴다든지, 스텁이나 모의 객체를 활용한다든지) 해당  
객체를 테스트하기 어렵다.  
  
# **컴포넌트와 컨테이너**  
컴포넌트는 애플리케이션 또는 애플리케이션의 일부를 말한다. 컨테이너는 컴포넌트가 실행되고 있는 격리된 공간을 말한다. 컨테이너는 생애 주기, 보안  
트랜잭션 등 컴포넌트를 위한 서비스를 제공한다.  
  
# **모의 객체를 활용한 테스트**  
isAuthenticated 메서드를 단위 테스트하기 위해 고려할 만한 첫 번째 방법은 모의 객체 개념을 사용하려 HttpServletRequest 객체를 모의  
하는 것이다. 그러나 모의 객체를 사용하더라도 테스트를 실행하려면 여전히 많은 코드를 작성해야 한다. 다만 EasyMock을 사용하여 모의 객체를 조금  
쉽게 만들 수는 있다.  
  
EasyMock을 활용하여 서블릿 테스트하기  
servlet 패키지 -> TestSampleServletWithEasyMock 클래스 참조  
  
JMock을 활용하여 서블릿 테스트하기  
servlet 패키지 -> TestSampleServletWithJMock 클래스 참조  
  
Mockito를 활용하여 서블릿 테스트하기  
servlet 패키지 -> TestSampleServletWithMockito 클래스 참조  

이렇게 최소한의 컨테이너를 모의 하는 것은 컴포넌트를 테스트하는 데 효과가 있다. 그러나 컨테이너를 모의하기 위해서는 복잡한 코드를 짜야 할 수도  
있다. 다른 테스트와 마찬가지로 만약 서블릿이 변경된다면, 기대도 그에 맞게 변경되어야 한다.  
  
# **컨테이너 활용하기**  
SampleServlet 클래스를 테스트하기 위해 HttpServletRequest와 HttpSession 객체를 갖고 있는 컨테이너를 직접 사용한다. 이렇게 하면 굳이  
모의 객체를 사용할 필요 없이 실제 컨테이너에서 필요한 객체와 메서드에 직접 접근할 수 있다.  
  
현재 예제에서는 웹 요청과 세션이 각각 컨테이너에서 관리하는 실제 HttpServletRequest와 HttpSession 객체가 되어야 한다. 이렇게 컨테이너에서  
테스트를 배포하고 실행하는 메커니즘을 컨테이너를 활용한 테스트(in-container testing)라고 한다.  
  
# **컨테이너를 활용한 테스트 구현 전략**  
컨테이너를 활용한 테스트를 구현하는 방법은 서버 측과 클라이언트 측 두 가지 접근 방식으로 나뉜다. 첫 번째로 서버 측에서 컨테이너와 단위 테스트를  
제어해서 테스할 수 있다. 클라이언트 측에서 테스트를 실행할 수도 있다.  
  
컨테이너를 활용한 테스트의 일반적인 생애 주기  
1. 클라이언트에서 테스트 클래스 실행  
2. 서버 측에서 동일한 테스트 케이스 호출  
3. 도메인 객체 테스트  
4. 결과를 클라이언트에 반환  
  
테스트가 패키징되어 컨테이너와 클라이언트에 배포되면 JUnit runner가 클라이언트에서 테스트를 실행한다. 그러면 클라이언트는 HTTP(S)와 같은  
프로토콜을 통해 연결을 맺고 서버 측으로 동일한 테스트를 호출한다. 서버 측의 테스트는 HttpServletRequest, HttpServletResponse 같이  
일반적으로 많이 사용하는 객체로 도메인 객체를 테스트한다. 테스트 결과는 서버 측에서 클라이언트 측으로 반환하는데 IDE나 Maven이 수집할  
수 있다.  
  
# **컨테이너를 활용한 테스트 프레임워크**  
컨테이너를 활용한 테스트는 컨테이너와 상호작용해야 하는 코드를 테스트하거나 이전 절에서 사용한 HttpServletRequest와 같은 컨테이너 객체를  
테스트가 직접 만들지 못할 때 유용하다.

# **스텁, 모의 객체, 컨테이너 테스트 비교하기**  

# **스텁 평가**  
스텁은 주어진 클래스를 외부 환경으로부터 분리해 테스트하고 인스턴스 상태를 검증하는데 효과적이었다. 서블릿 컨테이너를 스텁으로 만들면 요청 수,  
서버 상태, 요청한 URL 등에 대해서도 추적이 가능하다. 그러나 스텁은 처음부터 사전에 정의된 동작만 할 수밖에 없다.  
  
반면 모의 객체를 사용하면 테스트마다 모의 객체가 수행할 동작을 기대하고 검증할 수 있다. 개발자는 모의 객체를 사용해 비즈니스 로직을 테스트하고  
특정 메서드를 몇 번 호출했는지도 테스트할 수 있다.  
  
스텁은 모의 객체보다 이해하기 쉽다. 스텁은 코드 추가 없이 테스트 대상 클래스를 격리할 수 있는데 이는 프레임워크를 주로 사용하는 모의 객체와  
비교된다. 그러나 스텁은 외부 도구에 의존하고 해킹과 유사한 방법을 사용해야 하며 가짜로 만든 객체의 상태는 추적하지 않는다는 문제가 있다.  
  
7장에서 스텁을 활용해 가짜 서블릿 컨테이너를 쉽게 만들 수 있었다. 만약 모의 객체로 서블릿 컨테이너를 대체해야 했다면 개발자가 컨테이너 객체의  
상태나 행동을 일일이 정의해야 해서 훨씬 힘들었을 것이다.  
  
스텁의 장점  
- 만들기 쉽고 이해하기 쉽다.  
- 그 자체로 강력하다.  
- 거친 테스트에 적합하다.  
스텁의 단점  
- 상태를 확인하기 위해 특별한 방법이 필요하다.  
- 가짜로 만들어 낸 객체의 동작까지는 테스트하지 않는다.  
- 복잡한 상호작용을 따라가기 위해 너무 많은 시간이 든다.  
- 코드를 변경할 때마다 추가적인 유지 보수가 필요하다.  
  
# **모의 객체 평가**  
컨테이너를 활용한 테스트와 달리 모의 객체가 가진 가장 큰 장점은 모의 객체는 테스트를 수행하기 위해 굳이 컨테이너가 필요하지 않다는 것이다.  
컨테이너가 필요 없는 만큼 테스트를 빠르게 구성하고 실행할 수 있다. 반면 모의 객체를 활용해서 테스트에 성공한 컴포넌트가 실제 배포되는 컨테이너에서도  
정상적으로 실행될 지 알 수 없다는 단점이 있다. 모의 객체를 활용한 테스트는 컴포넌트와 컨테이너간의 상호작용을 검증할 수는 없기 때문이다.  
게다가 모의 객체를 활용한 테스트는 컴포넌트 각각의 세밀한 동작을 검증하는 데 특화되어 있으므로 컨테이너 안에서 동작하는 컴포넌트 간의 상호작용을  
테스트하지는 않는다.  
  
그러므로 다른 개발팀이나 개발자가 만든 모듈이 함께 잘 작동하는지 확인하기 위해 통합 테스트를 수행할 필요성이 여전히 존재한다. 이럴 때 잘  
만들어진 기능 테스트를 수행할 수 있다면 목표를 달성할 수 있을 것이다. 그러나 기능 테스트를 수행할 떄는 기능 테스트가 거칠 뿐더러 유스 케이스  
전체를 테스트하는 것만 가능하다는 문제가 있다. 기능 테스트만 수행할 경우에는 세밀한 단위 테스트의 이점을 거의 잃게 된다. 기능 테스트만을 가지고  
단위 테스트가 커버한 만큼의 다양한 케이스를 테스트할 수는 없기 때문이다.  
  
모의 객체에 또 다른 단점이 있는데 예를 들어 구성해야 하는 모의 객체가 너무 많을 때에는 모의 객체만으로도 무시하지 못할 부담이 된다. 모의 객체를  
관리하는데 들어가는 운영 비용이 상당할 수 있는 것이다. 물론 테스트 대상 코드가 깨끗하고 분명하게 작성되었다면 테스트를 더 쉽게 구성할 수   
있다는 점은 어디에나 적용되는 이야기이다.  
  
그 외에 다른 단점으로는 테스트를 구성하기 위해 모의한 API가 어떻게 작동할 것인지 정확하게 알아야 한다는 것이다. 떄때로 외부 도메인에 대한  
지식이 필요할 수도 있다. 개발자는 모든 프로젝트의 다양한 서드 파티 라이브러리에 대한 버그, 트릭, 핵을 일일이 다 알아야 할 수도 있다.  
  
모의 객체 장점  
- 테스트를 실행하기 위해 굳이 컨테이너를 구동할 필요가 없다.  
- 테스트를 빠르게 설정하고 실행할 수 있다.  
- 세밀한 단위 테스트가 가능하다.  
  
모의 객체 단점  
- 컨테이너와 컴포넌트, 컴포넌트 간의 상호작용을 테스트할 수는 없다.  
- 컴포넌트의 배포는 테스트하지 못한다.  
- 모의할 API에 대한 충분한 도메인 지식이 필요한데 특히 외부 라이브러리에 관해서는 지식을 습득하기 쉽지 않을 수 있다.  
- 대상 컨테이너에서 코드가 실행되리라는 확신을 주지 못한다.  
- 지나치게 세밀한 테스트만 작성되어 테스트 코드가 인터페이스로 가득 차 버릴 수도 있다.  
- 스텁과 마찬가지로 소스 코드가 변경되면 유지 보수가 필요하다.  
  

  

