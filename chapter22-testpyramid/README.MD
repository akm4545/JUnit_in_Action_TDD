# **JUnit5로 테스트 피라미드 전략 구현하기**  
# **소프트웨어 테스트 수준**  
테스트를 저수준부터 고수준으로 나열하자면 다음과 같다.  
- 단위 테스트: 단위 테스트는 테스트 피라미드의 기초를 이룬다. 개별 단위를 이루는 메서드나 클래스 각각을 격리해 테스트하고 테스트 대상이 예상한  
대로 작동하는지 확인한다.  
- 통합 테스트: 개별적으로 검증한 소프트웨어 구성 요소를 더 큰 덩어리로 합쳐서 테스트한다.  
- 시스템 테스트: 시스템이 명세를 잘 따르고 있는지 평가하기 위해 전체 시스템에서 테스트를 수행한다. 시스템 테스트는 설계나 코드에 대한 지식이  
필요하지 않으며 전체 시스템의 기능에 중점을 둔다.  
- 인수 테스트: 인수 테스트는 시나리오와 테스트 케이스를 사용하여 애플리케이션이 최종 사용자의 기대를 충족하는지를 검증한다.
  
테스트 피라미드의 각 단계는 작고 단순한 단위부터 크고 복잡한 단위에 이르기까지의 계층 구조를 보여 주며 개발이 진행되면서 테스트의 양상이 어떻게  
바뀌는지 보여 준다. 저수준 테스트는 개별 컴포넌트를 대상으로 한다. 세부 사항에 집중하고 넓은 범위에 관해서는 관심을 갖지 않는다. 고수준 테스트는  
추상적이다. 시스템의 전반적인 목표와 기능을 검증하고 GUI와 사용자가 어떻게 상호작용하는지 혹은 시스템이 전체적으로 어떻게 동작하는지에 더 관심을  
갖는다.  
  
소프트웨어를 테스트할 때 주로 검증해야 할 대상은 아래와 같다.  
- 비즈니스 로직: 프로그램이 실세계의 비즈니스 규칙과 절차를 이해하고 해석한 결과를 말한다.  
- 잘못된 입력: 예를 들어 항공편 관리 시스템에서는 항공편을 예약할 때 음수를 입력할 수 없다.  
- 경곗값 조건: 최댓값 또는 최솟값과 같은 도메인의 극단 값을 말한다. 경곗값 조건으로 승객이 0명 또는 만석인 항공편을 테스트할 수 있다.  
- 예상치 못한 조건: 프로그램에서 정상적인 비즈니스 로직을 따르지 않는 조건을 말한다. 예를 들어 항공편은 일단 이륙한 순간부터는 출발지를 변경할 수  
없다.  
- 불변성: 프로그램 실행 중에 값이 변경되지 않아야 한다. 
- 회귀: 시스템 업그레이드나 패치 후에 기존에는 없었던 버그가 생기면 안 된다.  
  
# **단위 테스트: 독립적으로 작동하는 기본 컴포넌트**  
Passenger 클래스, Flight 클래스  
phase1 패키지 -> airport 패키지 참조  
  
테스트 클래스  
phase1 패키지 -> airport 패키지 참조  
  
테스트를 실행하면 성공적으로 수행되며 코드 커버리지는 100%를 달성한다.  
JUnit5 테스트를 사용하여 확인한 내용은 다음과 같다.  
- 승객 식별자 정보와 국가 코드에 대한 제약
- 항공편명에 대한 제약(영문 두 글자로 시작하고 그 뒤에 3~4자리의 숫자가 오는지)
- 잘못된 입력 값
- 경곗값 조건  
  
# **통합 테스트: 단위 간의 협력**  
통합 테스트는 문자 그대로 여러 단위를 통합해서 단위 간의 상호작용을 검증한다. 개별 단위에 문제가 없다고 해서 여럿이 함께 동작했을 때도 문제가  
없다는 것을 보장하지는 않기 때문이다.  
  
Passenger 클래스와 Flight 클래스는 서로 다른 단위를 나타내며 서로 협력하기 위해서는 적절한 인터페이스(여기서는 API)를 노출해야 한다. 그러나  
인터페이스를 만들다 보면 메서드가 누락될 수도 있고 적절한 타입의 파라미터를 받지 못하는 등 협럭을 방해하는 결함이 있을 수 있다.  
  
Flight 클래스에서 Passenger 클래스와 통합되도록 변경.  
phase2 패키지 -> airport 패키지 -> Flight 클래스 참조  
  
통합 테스트를 수행하기 위해 Arquillian을 사용한다. Arquillian은 JUnit과 잘 호환되며 자바 컨테이너 테스트를 실행할 수 있는 테스트  
테스트 프레임워크다.  
  
Arquillian에는 JUnit5 extension이 없다. 하지만 Arquillian은 매우 인기 있는 도구이고 JUnit4 까지는 자주 사용되었다. Arquillian을  
사용하면 컨테이너, 배포, 프레임워크 초기화 등을 관리하는 부담을 줄일 수 있다.  
Arquillian은 자바 EE 애플리케이션을 테스트하는 데 사용한다.  
  
ShrinkWrap은 Arquillian에서 사용하는 외부 의존성이다. 개발자는 ShrinkWrap을 사용해 간단하게 아카이브를 만들 수 있다. 개발자는 ShrinkWrap  
API를 사용하여 테스트 중에 Arquillian으로 배포할 jar, war, ear 파일을 직접 만들 수 있다. 아카이브 파일은 애플리케이션을 실행하는 데 필요한  
모든 클래스를 포함한다.  
  
ShrinkWrap은 테스트 대상인 자바 컨테이너에 업로드할 디스크립터와 디플로이먼트를 정의하는 데 도움이 된다.  
  
승객 리스트가 담긴 csv 파일  
resources 디렉토리 -> flights_information.csv 파일 참조  
  
csv 파일을 구문 분석하고 항공편에 승객 정보를 채워 넣는 클래스  
phase2 패키지 -> airport 패키지 -> FlightBuilderUtil 클래스 참조  
  
Arquillian은 컨테이너와 애플리케이션 시작을 추상화한 다음 애플리케이션을 대상 런타임(이 경우에는 애플리케이션 서버)에 배포하여 테스트를 실행할  
수 있다. Arquillian을 사용하기 위해서 pom.xml 파일에 의존성을 추가해야 한다.  
  
컨테이너에 대해 테스트를 실행하려면 해당 컨테이너에 맞는 의존성을 가지고 있어야 한다. 이 요구 사항은 Arquillian의 강점 중 하나를 보여 주는데  
Arquillian은 단위 테스트로부터 컨테이너를 추상화하므로 컨테이너를 활용한 테스트를 구현하는 특정한 도구와 밀접하게 결합되지 않는다.  
  
두 클래스 간의 통합 테스트  
phase2 패키지 -> airport 패키지 -> FlightWithPassengersTest 클래스 참조  
  
ShrinkWrap 아카이브가 서버에 배포되면 실제 아카이브가 되는 것이다. 컨테이너는 아카이브가 ShrinkWrap에 의해 패키징되었다는 사실을 알지 못하기  
때문이다.  
  
테스트를 실행하면 오류가 발생하는데 @Inject를 통해 의존성을 주입하려고 했지만 그러지 못했다. Flight 클래스에 파라미터가 있는 생성자만 있을 뿐  
컨테이너에서 사용할 기본 생성자를 선언하지 않았기 때문에 생긴 문제다. 구동할 당시에 컨테이너는 Flight 객체에 어떤 파라미터를 전달해야 할지 모르기  
때문에 파라미터가 있는 생성자를 호출할 수 없어 이런 문제가 생겼다.  
  
자바 EE는 사용자 정의 초기화가 필요한 객체를 주입할 수 있도록 설계된 생산자 메서드(producer method)를 제공한다.  
phase2 패키지 -> airport 패키지 -> producers 패키지 -> FlightProducer 클래스 참조  
  
FlightProducer 클래스를 ShrinkWrap 아카이브에 추가하면 된다.  
phase2 패키지 -> airport 패키지 -> FlightWithPassengersTest 클래스 참조  
  
테스트를 실행하면 정상적으로 구동되며 코드 커버리지가 100%를 달성한다. 컨테이너는 올바르게 구성된 항공편을 주입했다. 개발자는 테스트 피라미드의  
통합 계층을 성공적으로 구현한 것이다.  
  
# **시스템 테스트: 전체 소프트웨어 살펴보기**  
시스템 테스트는 말 그대로 전체 시스템을 테스트하여 명세를 준수했는지를 평가하고 통합된 단위 간에 오류가 있는지를 검증한다. 여기서는 모의 객체  
개념을 적용할 것이다. 모의 객체는 복잡한 실제 객체의 동작을 모사할 수 있으므로 실제 객체를 테스트하는 것이 실용적이지 않거나 불가능한 경우에  
유용하다. 테스트 시점에는 의존 컴포넌트를 아직 사용하지 못할 수 있기 떄문이다. 예를 들어 항공편 관리 시스템은 외부 조건을 측정하는 장치(온도나  
습도)에 의존할 수 있다. 이러한 장치들이 제공하는 결과는 굉장히 임의적일 뿐만 아니라 테스트의 결과에 영향을 미칠 수도 있다. 이는 우리가 특정  
시점의 특정 기상 상황을 예측할 수 없는 것과 같다.  
  
프로그램을 개발할 때 테스트 목표를 달성하기 위해 복잡한 실제 객체의 동작을 모사하는 모의 객체를 만들어야 할 수도 있다. 모의 객체를 사용하는  
일반적인 사례로는 지금 당장 사용할 수 없는 외부 또는 내부 서비스와의 통신을 들 수 있다. 이러한 종류의 서비스는 당장 사용하기 어렵거나 다른  
개발팀이 유지 보수하는 중일 수 있다. 이런 점들이 타 서비스와의 통신을 어렵게 또는 느리게 만드는 요인이다. 테스트 더블은 바로 이런 상황에서  
유용하다. 테스트 더블을 사용하면 다른 서비스가 가용한 상태가 되도록 굳이 기다릴 필요가 없다. 이렇게 모의 객체는 외부 서비스를 정확하게 대체하고자  
할 때 사용할 수 있다. 물론 의존 컴포넌트가 예상되는 종작이나 우리가 사용할 API의 명세를 잘 지키는 등 계약을 잘 따르는 것이 중요하다.  
  
의존 컴포넌트가 다른 팀에서 병렬적으로 개발된다면 소비자 주도 계약 방식을 적용하는 것이 좋을 것이다. 이는 공급자는 소비자가 예상한 대로 API를  
구현해야 함을 의미한다.  
  
# **모의 외부 의존성을 사용한 테스트**  
승객이 이동한 거리에 따라 보너스 포인트를 제공하는 신규 기능 추가  
보너스 포인트 정책은 10KM를 여행할 때마다 포인트 1점을 받는다.  
  
보너스 포인트 정책은 DistancesManager 클래스를 제공한 다른 팀으로 외부화된다. 개발자는 소비자와 공급자 간의 계약(contract)을 형성한다는 것을  
알고 있다. 즉 애플리케이션은 소비자 주도 계약을 따른다.  
  
개발자는 DistancesManager API가 다음 메서드를 제공한다는 것을 알고 있다.  
- getPassengersDistancesMap 메서드는 승객을 키로, 이동 거리를 값으로 갖는 맵을 반환한다.  
- getPassengersPointsMap 메서드는 승객을 키로, 보너스 포인트를 값으로 갖는 맵을 반환한다.  
- addDistance 메서드는 승객의 이동 거리를 추가한다.  
- calculateGivenPoints 메서드는 승객의 보너스 포인트를 계산한다.  
  
개발자는 아직 구체적인 구현을 모르는 상태이므로 더미로 로직을 구현하여 클래스의 동작을 모의한다.  
phase3 패키지 -> airport 패키지 -> DistancesManager 클래스 참조  
  
개발자는 한 개의 CSV 파일로 된 항공편의 정보를 가지고 있지만 이는 충분하지 않다. 로직이 정확하게 동작하는지 테스트하기 위해서는 복수의 항공편에  
등록된 승객 정보를 만들 필요가 있다. 두 개의 다른 항공편에 123-45-6790이라는 SSN을 갖고 James Perkins라는 이름을 가진 승객이 중복해 들어  
있도록 데이터를 구성한다.  
  
resources 디렉토리 -> flights_information2.csv, flights_information3.csv 파일 참조  
  
Flight 클래스에는 이동한 거리를 나타내는 distance 필드와 게터, 세터 메서드를 추가한다.  
  
같은 승객이 여러 항공편에 있는지 확인하기 위해 Passenger 클래스에 equals 메서드와 hashCode 메서드를 재정의한다.  
  
항공편을 식별하기 위해 항공편명을 파라미터로 사용하는 @FlightNumber 어노테이션을 만든다.  
phase3 패키지 -> airport 패키지 -> annotations 패키지 -> FlightNumber 어노테이션 참조  
  
FlightProducer 클래스에 "AA1234"를 항공편의 식별자로 사용할 파라미터로 사용하고 createFlight 메서드에 @FlightNumber 어노테이션을  
추가한다.  
phase3 패키지 -> airport 패키지 -> producers 패키지 -> FlightProducer 클래스 참조 
  
FlightWithPassengersTest 클래스를 수정하여 주입된 항공편에 어노테이션을 달고 DistancesManager에 대한 테스트를 작성한다.  
phase3 패키지 -> airport 패키지 -> FlightWithPassengersTest 클래스 참조  
  
# **부분적으로 구현한 외부 의존성을 사용한 테스트**  
개발자가 공급자로부터 DistancesManager 클래스가 일부 구현되었다고 연락을 받았고 가정하자.  
  
일부 구현된 DistancesManager 클래스  
phase3 패키지 -> airport 패키지 -> DistancesManager 클래스 참조  
  
남은 부분은 여전히 개발 중이겠지만 합의된 계약을 따르는 것에는 변함이 없다. 중요한 점은 여전히 API 계약이 존중된다는 것이다.  
개발자는 거리를 기준으로 보너스를 계산하는 방법을 알고 있다. 그러므로 passengersPointsMap이 아니라 passengersDistancesMap을 사용하여  
계산할 것이다.  
  
수정한 FlightWithPassengerTest 클래스  
phase3 패키지 -> airport 패키지 -> FlightWithPassengersTest 클래스 참조


  
