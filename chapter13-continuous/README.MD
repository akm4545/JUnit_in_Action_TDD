12장은 IDE 사용법이라 생략  
  
# **테스트와 지속적 통합**  
통합 테스트는 대체로 시간이 매우 많이 걸리는 작업이다. 그리고 개발자 한 명이 모든 모듈을 로컬에 전부 저장해 놓고 있지도 않을 것이다.  
그러므로 개발 중에 모든 통합 테스트를 실행한다는 것은 현실성 없는 이야기다. 당연한 것이 개발 중에 개발자들은 주로 각자의 모듈에  
집중하고 자신이 개발하는 단일 모듈이 동작을 잘하고 있는지 생각할 뿐 다른 모듈까지 고려하기는 어렵기 때문이다. 개발 중에는 자신이 개발한  
모듈에 적절한 데이터를 집어 넣었을 때 예상대로 동작하고 예측한 결괏값을 내놓는지를 확인하는 것이 가장 중요하다.  
  
JUnit 테스트를 개발 주기 안에 포함하는 것은 굉장히 중요한 일이다(일반적으로 개발 주기는 코드 작성 -> 구동 -> 테스트 -> 코드작성을  
말하고 만약 TDD를 적용한다면 테스트 -> 코드 작성 -> 구동 -> 테스트가 일반적인 개발 주기가 될 것이다). JUnit 테스트는 단위  
테스트이므로 프로젝트를 다른 모듈로부터 격리해 테스트할 수 있다. 한편 많은 시스템이 개발작 각자가 일부 모듈을 맡아 개발하는 모듈식  
구조로 되어 있다. 개발자들은 자기가 개발한 모듈이 잘 동작하는지 확인하기 위해 자신이 만든 모듈과 테스트에 관심을 갖는다.  
  
모듈은 서로 통신하게끔 되어 있다. 그러므로 모든 모듈을 한데 모았을 때 함께 잘 동작하는지 확인할 필요가 있다. 이렇게 애플리케이션  
전체를 테스트하기 위해서는 통합 테스트나 기능 테스트 같은 테스트가 필요하다.  
  
TDD는 더 일찍, 더 자주 테스트하는 것을 권장했다. 하지만 사소한 수정 하나하나에 단위 테스트, 통합 테스트, 기능 테스트를 다 수행해야  
한다면 개발진행 속도는 무척 느려질 것이다. 이런 일이 일어나지 않도록 개발을 진행하고 있을 때 되도록 빨리, 자주 단위 테스트를 돌려 볼  
것이다.  
  
통합 테스트는 개발 프로세스와는 독립적으로 수행하는 게 좋다. 특히 주기적으로(예를 들어 15분마다) 실행되는 것이 가장 좋다. 이렇게 하면  
문제가 생겼을 때 15분 내에 문제에 관한 알림을 받을 수 있고 빠른 시간 내에 문제를 해결할 수 있다.  
  
주기적인 간격으로 통합 테스트를 실행하려면 관련된 시스템 모듈이 이미 준비되고 빌드되어 있어야 한다. 모듈이 빌드되고 통합 테스트가  
실행된 후에는 가능한한 빨리 결과를 확인해야 한다. 그러므로 아래와 같은 단계를 모두 자동화하기 위해서는 적절한 도구가 필요하다.  
  
1. 형상 관리 시스템에서 프로젝트를 체크아웃(복사)한다.  
2. 각 모듈을 빌드하고 단위 테스트를 실행하여 각 모듈이 격리된 상태에서 예상대로 동작하는지 검증한다.  
3. 통합 테스트를 실행하여 모듈 간 통합이 예상대로 잘되었는지 검증한다.  
4. 3단계에서 실행한 테스트 결과를 리포트로 만든다.  
  
이 모든 과정은 사람이 수행하는 것과 도구가 수행하는 것과의 차이는 없으며 차이가 있어서도 안 된다.  
  
지속적 통합 도구는 주로 프로젝트를 가져오기 위해 형상 관리 시스템과 함께 사용된다. 그런 다음 빌드 도구를 사용하여 프로젝트를 빌드한  
뒤 각종 테스트를 실행한다. 마지막으로 지속적 통합 고두로 결과를 게시하고 모두가 알 수 있도록 알림을 보낸다.  
  
이 네 단계는 매우 일반적인 과정이며 개선할 여지가 많다. 예를 들어 빌드 시작 전에 버전 관리 시스템에서 변경이 일어났는지 먼저 확인할  
수 있다. 변경이 없었다면 컴퓨터의 CPU 성능만 낭비하는 꼴이 된다. 당연히 똑같은 결과를 얻을 것이기 때문이다.    
  
# **지속적 통합**  
개발자들이 되도록 자주 작업의 결과물을 통합해야 한다는 소프트웨어 개발 실천 방법. 일반적으로는 최소 1일 1회 이상 통합을 권장하며  
하루에 여러 번 통합할 수도 있다. 대부분의 통합은 자동화된 빌드와 테스트 과정을 거쳐 검증이 되는데 이러한 과정을 통해 통합 시 발생하는  
문제를 매우 빠르게 찾아낼 수 있다. 지속적 통합을 통해 문제를 획기적으로 줄일 수 있고 더욱 응집력 있는 소프트웨어를 빠르게 개발할 수  
있다.  
  
# **젠킨스 살펴보기**  
젠킨스 설치시 가장 중요한 파일은 jenkins.war이다.  
  
젠킨스 설치 폴더에서 젠킨스 서버 구동  
  
java -jar jenkins.war  
  
젠킨스 구동 후 구동 url로 접속하면 초기 암호값이 initialAdminPassword 파일로 생성된다. 암호를 입력하고 로그인하면 플러그인 설치  
화면이 나온다. [Install suggested plugins]를 선택하여 유용한 플러그인을 설치할 수 있다. 아이템을 그룹화할 폴더 플러그인, CUP나  
HTTP 응답 시간, 메모리 등을 확인할 수 있는 모니터링 플러그인, 헬스 체크를 도와주는 메트릭 플러그인도 있다. 
  
설치 후 어드민 계정을 만들기 위한 자격 증명 생성 페이지가 나타난다. 필요한 정보를 작성한 뒤 [Save and Continue] 버튼을 클릭한다.  
  
# **지속적 통합 실천하기**  
예제로 항공편 관리 시스템을 사용하며 개발자 각각이 승객과 항공편에 대한 부분을 개발한다고 가정한다. 각자 맡은 부분의 테스트는 자체적으로  
수행한다.  

passenger 예제  
passengers 패키지 참조(클래스 및 테스트 클래스)  

flights 예제    
flights 패키지 참조(클래스 및 테스트 클래스)  
  
Passenger 클래스와 Flight 클래스 간의 통합 테스트 예제  
flightspassengers 패키지 참조  
  
이 프로젝트에서 사용한 코드는 깃으로 관리한다.  
  
# **젠킨스 설정하기(로컬 저장소 기준)**  
젠킨스는 웹 인터페이스를 통해 구성할 수 있다. 웹 인터페이스에 접근하기 위해 젠킨스 URL로 접근한다. 지금까지는 지속적 통합을 실행할 대상이  
없었으므로 [New Item] 버튼을 클릭하여 새로운 젠킨스 잡을 만든다. Enter the item name 항목에는 이름을 입력하고 Free style project  
를 선택한다. 그리고 [OK] 버튼을 누른다. 다음 페이지로 넘어가면 Source Code Management 항목에서 Git을 선택한다. 그리고 Repository  
URL 항목에 깃 저장소 경로를 입력한다. 아래쪽으로 내려가서 Build 항목에서 [Add Build Step] -> [Invoke Top level Maven Targets]  
를 누른 다음 Goals 항목에 clean install을 입력한다. 그다음 [Save] 버튼을 클릭한다.  
  
이제 젠킨스 대시보드에서 새로 생성한 지속적 통합 프로젝트를 확인할 수 있다. 프로젝트 목록 가장 오른쪽에 있는 [Build] 버튼을 클릭하고  
빌드가 완료될 때까지 기다린다.  
  
빌드가 성공적으로 수행되었고 화면에 초록색 표시가 뜬다면 지속적 통합 관점에서 모든 것이 괜찮다고 볼 수 있다.  
  
개발 작업을 하는 중에 개발자는 단위 테스트를 주로 실행하며 통합 테스트는 개발 프로세스와 독립적으로 수행된다.  
  
# **지속적 통합 환경에서 작업하기**  
새로운 기능을 추가 개발한다고 가정하자. 항공편에 승객을 추가할 뿐만 아니라 승객 쪽에도 항공편에 추가되어야 한다. 승객이 스스로 항공편을  
선택할 수 있는 상호작용이 가능한 시스템이어야 하므로 이는 반드시 필요한 기능이다. 현재로서도 항공편에 승객을 추가할 수는 있다. 그러나  
승객 쪽에서 승객이 어느 항공편을 이용했는지는 알지 못한다.  
  
문제 해결을 위해 Flight 클래스와 Passenger 클래스 사이에 양뱡향 참조가 가능하게 만들었다.  
개발자는 FlightWithPassengersTest 클래스에 테스트를 추가하고 기존 테스트를 수정한다.  
  
개발자는 추가 개발한 코드를 지속적 통합 서버로 푸시한다. 사실 개발자의 로컬 프로젝트도 원격의 깃 서버에서 관리하는 것이다. 이는 지속적  
통합 서버에 있는 코드의 복제본이라고 볼 수 있다.  
  
git push 명령을 실행해 코드를 지속적 통합 서버로 밀어 넣으면 새로운 빌드가 진행될 것이고 아마 그 빌드는 실패할 것이다. 젠킨스 콘솔  
화면에서 보면(Job의 이름 링크를 클릭한 다음 [Build History] 메뉴에서 빌드 번호 아이콘을 클릭하면 해당 빌드 정보를 볼 수 있다.  
거기서 [Console Output]을 클릭한다.) 수정한 테스트가 실패하는 것을 확인할 수 있다.  
  
개발자는 빌드가 실패한 뒤 켄진스의 콘솔 아웃풋을 확인하여 Flight와 Passenger 간의 관계에 문제가 있다는 것을 알게 되었다. 그리고  
개발자는 서로 양방향 참조를 하는 부분에 미흡한 점이 있다는 것을 알게 되었다.  
  
다른 개발자가 양방향 참조에 문제가 있는 코드를 수정하고 위와 같이 코드를 지속적 통합 서버로 푸시하면 새로운 빌드가 진행된다. 그리고  
그 빌드는 성공한다.  
  
지속적 통합 덕분에 통합과 관련한 문제를 신속하게 확인할 수 있었고 개발자가 문제를 즉시 해결할 수 있었다. JUnit5와 젠킨스가 시너지  
효과를 낸 덕분이다.  


  

  
