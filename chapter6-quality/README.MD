# **테스트 커버리지 측정하기**  
단위 테스트를 작성하면 애플리케이션을 변경하고 리팩토링할 때 확신을 가질 수 있다. 소스 코드를 바꾼 뒤  
테스트를 돌려 보면 추가한 기능과 변경 내역이 기존 테스트를 통과하는지 못하는지 바로 알 수 있다. 문제는  
코드를 변경함으로써 기존 테스트로 커버하지 못했던 기능이 동작하지 않을 수 있다는 것이다.  
이 문제를 해결하기 위해서는 사용자나 개발자가 테스트를 수행할 때 정확히 어떤 코드가 실행되고 어떤 코드가  
실행이 되지 않는지 알아야 한다. 이상적으로는 테스트가 애플리케이션 코드의 100%를 커버하는 게 좋다.  
테스트 커버리지는 그 자체로 코드의 품질을 어느 정도 보증한다. 하지만 이는 여전히 논란의 여지가 있는 지표다.  
높은 테스트 커버리지가 테스트의 질을 보장하지 않기 떄문이다. 훌륭한 개발자는 테스트를 실행하여 얻어 낸  
기계적인 백분율수치 이상을 볼 수 있어야 한다.  
  
# **테스트 커버리지란 무엇인가**  
블랙박스 테스트 시 테스트 커버리지를 계산하는 데 다양한 지표를 사용할 수 있다. 가장 기본적인 지표는 테스트 묶음을 실행하는  
동안 호출되는 애플리케이션의 메서드나 코드 줄의 수를 가지고 나타낸 백분율이다. 또 다른 지표로 테스트가  
호출하는 메서드를 추적해서 집계할 수 있다. 이 결과는 테스트가 성공했는지를 알려 주지 않는다. 하지만 메서드에  
대한 테스트가 있는지 없는지를 알려 줄 수는 있다.  
  
화이트박스 테스트 시 메서드가 어떻게 구현되어 있는지 자세히 알고 있다면 단위 테스트를 작성할 수 있다.  
테스트 대상 메서드에 분기문이 있을 경우 각 분기마다 하나씩 단위 테스트를 작성해야 한다.  
  
일반적으로 화이트박스 테스트(단위 테스트)를 활용하면 더 높은 테스트 커버리지를 얻을 수 있다. 더 많은 메서드에  
접근할 수 있을뿐더러 각 메서드에 대한 입력과 보조 객체의 동작을 제어할 수 있기 떄문이다.  
화이트박스 테스트는 protected 메서드, package-private 메서드, public 메서드에도 실행할 수 있으므로 블랙박스  
테스트보다 일반적으로 코드 커버리지가 더 높게 나온다.  
  
블랙박스 테스트로 높은 코드 커버리지를 달성하지 못했다면 보통은 더 많은 테스트가 필요하다는 뜻이다(애플리케이션에  
아직 테스트하지 않은 부분이 있을 것이다). 혹은 비즈니스 목표에 기여하지 않는 불필요한 로직이 있을 수 있다.  
두 경우 모두 실제 원인을 찾기 위해 추가적인 분석이 필요하다.  
  
테스트 커버리지가 높은 프로그램에서는 테스트를 실행할 때 보통 더 많은 코드가 실행된다. 테스트 커버리지가 낮은 프로그램  
보다 발견되지 않은 버그가 더 적을 수 있다.  
  
# **코드 커버리지를 측정하는 도구**  
코드 커버리지 도구는 JUnit과 통합이 잘되어 있다. 실제로 IntelliJ IDEA를 활용하면 코드 커버리지를 편리하게 집계할 수 있다.  
테스트 클래스 오른쪽 클릭 후 [Run ** with Coverage]를 클릭해 테스트 커버리지를 측정할 수 있다.  
테스트 리포트 창에서 [Generate Coverage Report]를 클릭하면 HTML 형식의 리포트도 생성할 수 있다.    
HTML 리포트는 패키지 수준일 수도 있고 클래스 수준일 수도 있으며 개별 코드 줄 수준일 수도 있다.  
명령 프롬프트에서 코드 커버리지 테스트를 실행하는 것을 권장하는데 이는 지속적 통합(continuous integration, CI)이나  
지속적 전달(continuous delivery, CD)을 이루는 일이기도 하다. 이를 위해서는 JaCoCo(Java Code Coverage) 플러그인을 사용하는  
것이 좋다. JaCoCo는 자주 업데이트되고 Maven과 통합이 매우 잘되어 있는 오픈 소스 도구다.  
  
JaCoCo 플러그인 추가  
pom.xml 참고  
  
명령 프롬프트에서 mvn test 명령을 실행하면 테스트 클래스에 대해 코드 커버리지 리포트를 생성한다.  
리포트는 프로젝트 폴더 내 target/site/jacoco 경로에서 확인할 수 있다.

# **테스트하기 쉬운 코드 작성하기**  
테스트 코드 작성은 쉬울 때도 있고 어려울 때도 있는데 애플리케이션이 얼마나 복잡한지에 따라 다르다.  
가장 좋은 사례는 가독성이 좋고 테스트하기 편하도록 가능한 한 소스 코드를 단순하게 작성하는 것이다.  
테스트하기 쉽도록 기존 코드를 리팩토링하는 것보다 테스트하기 쉬운 코드를 작성하는 것이 더 쉽다.  
  
# **public API는 정보 제공자와 정보 사용자 간의 계악이다**  
하위 호환성을 제공하는 소프트웨어를 만들 떄의 원칙은 public 메서드의 그니처를 변경하면 안 된다는 것이다.  
애플리케이션 코드를 보면 호출은 보통 외부의 다른 애플리케이션에서 일어나는 것을 알 수 있다. 이때 외부  
애플리케이션은 해당 API의 클라이언트와 같은 역할을 한다. public 메서드의 시그니처를 변경했다면 애플리케이션이나  
단위 테스트의 메서드 호출을 전부 변경해야 한다.  
  
특히 TDD로 작업한다면 초기 개발 단계에서 API를 리팩토링하는 것도 좋다. 아직 사용자가 없기 떄문이다.  
프로젝트를 오픈 소스화하거나 상용 제품의 API를 공개할 때는 훨씬 더 문제가 복잡하다. 많은 사람이 코드를  
사용하게 되므로 소스를 수정할 때마다 하위 호환성을 유지하기 위해서 매우 많은 노력과 주의를 기울여야 한다.  
public 메서드는 일반적으로 서로의 존재를 알지 못하는 컴포넌트, 오픈 소스 프로젝트, 상용 제품 등 애플리케이션의  
연결 지점이 된다.  
  
public 메서드의 변경으로 인한 단위 불일치 문제는 1999년 나사의 화성 기후 궤도선 폭발 사건의 원인이기도 하다.  
단위 불일치 사례는 왜 모든 public 메서드를 테스트해야 하는지를 잘 보여 준다. 물론 public이 아닌 메서드도  
자세히 분석해서 화이트박스 테스트를 수행해야 한다.  
  
# **의존성 줄이기**  
단위 테스트는 코드를 격리된 상태에서 검증한다는 점을 명심해야 한다. 단위 테스트는 테스트 대상 클래스를  
인스턴스화한 다음 테스트 대상 단위를 사용해 보고 나서 정확성을 검증한다. 그러므로 테스트 케이스는 단순해야 한다.  
클래스 안에서 새로운 객체를 직간접적으로 인스턴스화하면 클래스의 의도에 따라 인스턴스 객체가 달라질 것이다.  
테스트하기 쉬운 코드를 작성하려면 의존성을 최대한 줄여야 한다. 클래스가 인스턴스화되고 특정한 상태로 설정해야 하는  
다른 클래스에 많이 의존하는 경우 테스트하기가 매우 복잡해지며 복잡한 모의 객체를 만들어야 할 수도 있다.  
  
의존성을 줄이려면 메서드를 분리해야 한다. 특히 객체를 인스턴스화하는 메서드(주로 팩토리 메서드)와  
비즈니스 로직을 갖고 있는 메서드를 분리하는 것이 중요하다.
  
의존성 줄이기 예제  
car 패키지 -> Vehicle, Vehicle1 참조  
  
# **간단한 생성자 만들어 보기**  
car 패키지 -> Car 참조  
  
Car 클래스는 생성자에서 인스턴스 변수에 값을 할당하므로 아래 일을 수행한다.    
- 테스트할 클래스를 인스턴스화한다.  
- 클래스를 특정 상태로 설정한다.  
이는 설계 관점에서는 물론이고 클래스를 미리 정의한 상태로 가져오기 떄문에 좋지 못한 예제라고 볼 수 있다.  
클래스를 인스턴스화할 때마다 같은 일을 반복하기 떄문이다. 유지 보수나 테스트가 어려운 것은 물론이다.  
  
클래스를 특정 상태로 설정하는 것은 별도의 작업으로 분리해야 한다.  
car 패키지 -> Car1 참조  
  
# **데메테르 법칙 따르기**  
최소 지식의 법칙으로도 알려져 있는 데메테르 법칙은 클래스는 알아야 할 만큼의 정보만 가져야 한다는 것이다. 데메테르의 법칙은  
다음과 같이 설명할 수 있다.  
  
가까운 친구와 이야기하라 또는 낯선 이와 이야기하지 말라  
  
데메테르 법칙을 위반한 사례  
car 패키지 -> Car2 참조  
  
이 예제에서는 Context 객체를 Car 생성자에 전달한다. Context 객체는 드라이브에 대한 정보를 가지고 있다. 이 코드는  
데메테르 법칙을 위반하는데 Car 클래스가 Context 객체에 getDriver 메서드가 있다는 것을 알아야 하기 떄문이다.  
그러므로 Car 클래스의 생성자를 테스트하고 싶다면 생성자를 호출하기 전에 유효한 Context 객체를 가져오는 것이 선행되어야 한다.  
만약 Context 객체가 다양한 변수와 메서드를 갖는다면 Context 객체를 모사한 모의 객체를 사용해야 할지도 모른다.  
  
이런 상황에서 적절한 해결책은 데메테르 법칙을 적용하여 메서드나 생성자에 정확히 필요한 참조만 전달하는 것이다.  
이 사례에서는 Driver 객체만 Car 생성자에 전달해야 한다.  
  
Car(Driver driver)  
  
객체를 요구하되 객체 안에서 다시 찾지 않으며 현재 애플리케이션에 꼭 필요한 객체만 요청한다. 이것이 데메테르 법칙의 핵심이다.  
  
# **숨은 의존성과 전역 상태 피하기**  
전역 상태는 매우 주의해서 관리해야 한다. 정말 많은 클라이언트가 전역 객체를 사용할 수 있기 때문이다. 전역 상태를 공유하는 것은  
때때로 의도하지 않은 결과를 만들어 낸다. 공유 접근을 고려하지 않은 코드에서 전역 객체가 사용되거나 클라이언트가 전역 객체가  
배타적일 거라 생각하고 접근할 때는 더욱 위험하다.  
  
db 패키지 -> DBRun 클래스 참조  
  
구현 개선  
db 패키지 -> DBRun1 클래스 참조  
  
전역 상태는 되도록 피하는 게 좋다. 전역 객체에 대한 접근을 허용하면 단순히 전역 객체에만 접근을 공유하는 게 아니라 그 전역  
객체가 참조하는 모든 객체를 공유하게 되기 떄문이다.  
  
# **제네릭 메서드 사용하기**  
팩토리 메서드와 같은 정적 메서드는 매우 유용하지만 많은 정적 유틸 메서드에 문제가 있다. 단위 테스트는 격리된 테스트이다.  
코드에서 격리성을 갖기 위해서는 테스트 코드로 교체할 만한 연결 지점이 있어야 한다. 그리고 이런 경우엔 다형성을 활용하는 것이 도움이 된다.  
하나의 객체가 둘 이상의 IS-A 관계를 갖도록 만드는 다형성을 활용한다면 호출할 메서드가 컴파일 타임에 결정되지 않도록 만들 수 있다.  
다형성을 활용하여 애플리케이션 코드를 테스트 코드로 대체해 특정한 코드를 테스트해 볼 수 있다.  
  
그런데 정적 메서드만 사용한다면 반대 상황이 발생한다. 절차적 프로그래밍을 수행할 때처럼 메서드 호출이 거의 항상  
컴파일 타임에 결정된다. 코드를 유연하게 만드는 연결 지점이 없어지는 것이다.  
  
때로는 정적 메서드가 테스트에 미치는 영향이 크지 않을 수 있는데, 특히 Math.sqrt()처럼 그 자체로 완결성이 있는  
메서드는 더욱 그러하다. 그러나 복잡한 비즈니스 로직을 다루는 메서드나 정적 메서드 안에서 실행되고 있는 메서드들은  
테스트하기가 매우 까다롭다.  
  
정적 코드를 남발하거나 애플리케이션을 개발 시 다형성을 활용하지 못하면 애플리케이션뿐만 아니라 테스트에도 문제가  
생긴다. 다형성을 활용하지 않는다는 것은 애플리케이션과 테스트 모두에서 코드를 재사용하지 않는다는 뜻이기  
때문이다. 이런 상황은 애플리케이션과 테스트에서 코드 중복이 생길 수 있으므로 반드시 피해야 한다.  
  
결론적으로 파라미터에 구체적인 타입을 명시해야 하는 정적 유틸 메서드가 있다면 반드시 제네릭을 사용해야 한다.  
  
두 집합의 합집합을 반환하는 메서드  
`public static Set union(Seq s1, Set s2){

    Set result = new HashSet(s1);
    result.addAll(s2);
    return result;
}`
  
이 메서드는 컴파일은 되지만 타입 관련 경고가 나온다.  
메서드를 타입 체크로부터 안전하게 하고 경고를 없애려면 세 set에 대해 타입 파라미터를 선언한 다음 메서드에 타입 파라미터를  
사용하면 된다.  
  
`public static <E> Set<E> union(Set<E> s1, Set<E> s2{

    Set<E> result = new HashSet<>(s1);
    result.addAll(s2);
    return result;
}`  
  
제네릭 메서드를 사용하면 컴파일 시 경고가 뜨지도 않고 타입 안정성이 보장되며 사용 및 테스트하기가 쉽다.  
  
# **상속보다는 합성 활용하기**  
개발자들은 코드 재사용을 위해 상속을 활용하곤 한다. 그러나 상속보다는 합성이 테스트하기 쉽다. 런타임에 상속 구조를  
변경할 수는 없지만 객체를 다르게 합성하는 것이 가능하기 떄문이다. 결국 목표는 런타임 시 코드를 최대한 유연하게 만드는  
것이다. 합성을 사용하면 객체의 상태를 변화시키는 게 쉬워지고 테스트하기 쉬워진다.  
  
상위 클래스와 하위 클래스가 동일한 개발자의 제어하에 있는 패키지 내에 있다면 상속을 활용하는 게 바람직하다. 그러나  
패키지 밖의 구체 클래스를 상속하는 것은 위험할 수 있다.  
  
하위 클래스가 상위 클래스의 서브타입일 때 상속을 고려하는 것이 좋다. 클래스 A와 B가 있을 때 이를 연관지을 수 있는지  
생각해 보자. 클래스 B가 클래스 A를 상속해야 한다면 두 클래스 간에 IS-A 관계가 있어야 한다.  
  
자바 라이브러리에서 이 원칙을 어긴 경우도 있다. 스택은 벡터가 아니므로(IS-A 관계가 아니므로) Stack은 Vector를 상속해서는  
안 되었다. 마찬가지고 속성 리스트는 해시 테이블이 아니므로 Properties 클래스는 Hashtable 클래스를 상속해서는 안 되었다.  
두 경우 IS-A가 아닌 HAS-A 관계, 상속보다는 합성을 사용하는 것이 바람직하다.  
  
IS-A 관계 (상속 관계)  
하위 관계  
동물은 생물이다.  
고양이는 동물이다.  
  
HAS-A 관계 (구성 관계)   
포함하고 있음을 의미  
자동차는 엔진을 가진다.  
사람은 심장을 가진다.  
  
# **분기문보다는 다형성 활용하기**  
테스트에서 수행하는 작업은 다음 순서를 따른다.    
- 테스트할 클래스를 인스턴스화한다.  
- 클래스를 특정 상태로 설정한다.  
- 클래스의 최종 상태를 검증한다.  

문제는 세 단계 중 어느 곳에서도 발생할 수 있다. 예를 들어 클래스가 너무 복잡하면 인스턴스화가 어려울 수 있다.  
복잡도를 낮추기 위해서는 switch 문이나 if 문으로 길게 늘어진 분기문을 만들지 않으면 된다.  
  
나쁜 분기문 예제  
printer 패키지 -> bad 패키지 -> DocumentPrinter 클래스 참조  
  
분기문이 길고 복잡해진다면 다형성을 활용하는 것을 고려해 보자. 다형성은 객체를 여러 작은 클래스로 나누어 길고 복잡한 분기문을  
대체할 수 있게 해 주는데 이는 객체 지향 관점에서도 자연스럽다. 여러 작은 요소를 테스트하는 것은 크고 복잡한 요소를 테스트하는  
것보다 훨씬 쉽다.  
  
분기문 대체 예제  
printer 패키지 -> good 패키지 -> DocumentPrinter 클래스 참조  
  

  





  
