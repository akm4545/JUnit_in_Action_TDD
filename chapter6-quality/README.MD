# **테스트 커버리지 측정하기**  
단위 테스트를 작성하면 애플리케이션을 변경하고 리팩토링할 때 확신을 가질 수 있다. 소스 코드를 바꾼 뒤  
테스트를 돌려 보면 추가한 기능과 변경 내역이 기존 테스트를 통과하는지 못하는지 바로 알 수 있다. 문제는  
코드를 변경함으로써 기존 테스트로 커버하지 못했던 기능이 동작하지 않을 수 있다는 것이다.  
이 문제를 해결하기 위해서는 사용자나 개발자가 테스트를 수행할 때 정확히 어떤 코드가 실행되고 어떤 코드가  
실행이 되지 않는지 알아야 한다. 이상적으로는 테스트가 애플리케이션 코드의 100%를 커버하는 게 좋다.  
테스트 커버리지는 그 자체로 코드의 품질을 어느 정도 보증한다. 하지만 이는 여전히 논란의 여지가 있는 지표다.  
높은 테스트 커버리지가 테스트의 질을 보장하지 않기 떄문이다. 훌륭한 개발자는 테스트를 실행하여 얻어 낸  
기계적인 백분율수치 이상을 볼 수 있어야 한다.  
  
# **테스트 커버리지란 무엇인가**  
블랙박스 테스트 시 테스트 커버리지를 계산하는 데 다양한 지표를 사용할 수 있다. 가장 기본적인 지표는 테스트 묶음을 실행하는  
동안 호출되는 애플리케이션의 메서드나 코드 줄의 수를 가지고 나타낸 백분율이다. 또 다른 지표로 테스트가  
호출하는 메서드를 추적해서 집계할 수 있다. 이 결과는 테스트가 성공했는지를 알려 주지 않는다. 하지만 메서드에  
대한 테스트가 있는지 없는지를 알려 줄 수는 있다.  
  
화이트박스 테스트 시 메서드가 어떻게 구현되어 있는지 자세히 알고 있다면 단위 테스트를 작성할 수 있다.  
테스트 대상 메서드에 분기문이 있을 경우 각 분기마다 하나씩 단위 테스트를 작성해야 한다.  
  
일반적으로 화이트박스 테스트(단위 테스트)를 활용하면 더 높은 테스트 커버리지를 얻을 수 있다. 더 많은 메서드에  
접근할 수 있을뿐더러 각 메서드에 대한 입력과 보조 객체의 동작을 제어할 수 있기 떄문이다.  
화이트박스 테스트는 protected 메서드, package-private 메서드, public 메서드에도 실행할 수 있으므로 블랙박스  
테스트보다 일반적으로 코드 커버리지가 더 높게 나온다.  
  
블랙박스 테스트로 높은 코드 커버리지를 달성하지 못했다면 보통은 더 많은 테스트가 필요하다는 뜻이다(애플리케이션에  
아직 테스트하지 않은 부분이 있을 것이다). 혹은 비즈니스 목표에 기여하지 않는 불필요한 로직이 있을 수 있다.  
두 경우 모두 실제 원인을 찾기 위해 추가적인 분석이 필요하다.  
  
테스트 커버리지가 높은 프로그램에서는 테스트를 실행할 때 보통 더 많은 코드가 실행된다. 테스트 커버리지가 낮은 프로그램  
보다 발견되지 않은 버그가 더 적을 수 있다.  
  
# **코드 커버리지를 측정하는 도구**  
코드 커버리지 도구는 JUnit과 통합이 잘되어 있다. 실제로 IntelliJ IDEA를 활용하면 코드 커버리지를 편리하게 집계할 수 있다.  
테스트 클래스 오른쪽 클릭 후 [Run ** with Coverage]를 클릭해 테스트 커버리지를 측정할 수 있다.  
테스트 리포트 창에서 [Generate Coverage Report]를 클릭하면 HTML 형식의 리포트도 생성할 수 있다.    
HTML 리포트는 패키지 수준일 수도 있고 클래스 수준일 수도 있으며 개별 코드 줄 수준일 수도 있다.  
명령 프롬프트에서 코드 커버리지 테스트를 실행하는 것을 권장하는데 이는 지속적 통합(continuous integration, CI)이나  
지속적 전달(continuous delivery, CD)을 이루는 일이기도 하다. 이를 위해서는 JaCoCo(Java Code Coverage) 플러그인을 사용하는  
것이 좋다. JaCoCo는 자주 업데이트되고 Maven과 통합이 매우 잘되어 있는 오픈 소스 도구다.  
  
JaCoCo 플러그인 추가  
pom.xml 참고  
  
명령 프롬프트에서 mvn test 명령을 실행하면 테스트 클래스에 대해 코드 커버리지 리포트를 생성한다.  
리포트는 프로젝트 폴더 내 target/site/jacoco 경로에서 확인할 수 있다.

# **테스트하기 쉬운 코드 작성하기**  
테스트 코드 작성은 쉬울 때도 있고 어려울 때도 있는데 애플리케이션이 얼마나 복잡한지에 따라 다르다.  
가장 좋은 사례는 가독성이 좋고 테스트하기 편하도록 가능한 한 소스 코드를 단순하게 작성하는 것이다.  
테스트하기 쉽도록 기존 코드를 리팩토링하는 것보다 테스트하기 쉬운 코드를 작성하는 것이 더 쉽다.  
  
# **public API는 정보 제공자와 정보 사용자 간의 계악이다**  
하위 호환성을 제공하는 소프트웨어를 만들 떄의 원칙은 public 메서드의 그니처를 변경하면 안 된다는 것이다.  
애플리케이션 코드를 보면 호출은 보통 외부의 다른 애플리케이션에서 일어나는 것을 알 수 있다. 이때 외부  
애플리케이션은 해당 API의 클라이언트와 같은 역할을 한다. public 메서드의 시그니처를 변경했다면 애플리케이션이나  
단위 테스트의 메서드 호출을 전부 변경해야 한다.  
  
특히 TDD로 작업한다면 초기 개발 단계에서 API를 리팩토링하는 것도 좋다. 아직 사용자가 없기 떄문이다.  
프로젝트를 오픈 소스화하거나 상용 제품의 API를 공개할 때는 훨씬 더 문제가 복잡하다. 많은 사람이 코드를  
사용하게 되므로 소스를 수정할 때마다 하위 호환성을 유지하기 위해서 매우 많은 노력과 주의를 기울여야 한다.  
public 메서드는 일반적으로 서로의 존재를 알지 못하는 컴포넌트, 오픈 소스 프로젝트, 상용 제품 등 애플리케이션의  
연결 지점이 된다.  
  
public 메서드의 변경으로 인한 단위 불일치 문제는 1999년 나사의 화성 기후 궤도선 폭발 사건의 원인이기도 하다.  
단위 불일치 사례는 왜 모든 public 메서드를 테스트해야 하는지를 잘 보여 준다. 물론 public이 아닌 메서드도  
자세히 분석해서 화이트박스 테스트를 수행해야 한다.  
  
# **의존성 줄이기**  
단위 테스트는 코드를 격리된 상태에서 검증한다는 점을 명심해야 한다. 단위 테스트는 테스트 대상 클래스를  
인스턴스화한 다음 테스트 대상 단위를 사용해 보고 나서 정확성을 검증한다. 그러므로 테스트 케이스는 단순해야 한다.  
클래스 안에서 새로운 객체를 직간접적으로 인스턴스화하면 클래스의 의도에 따라 인스턴스 객체가 달라질 것이다.  
테스트하기 쉬운 코드를 작성하려면 의존성을 최대한 줄여야 한다. 클래스가 인스턴스화되고 특정한 상태로 설정해야 하는  
다른 클래스에 많이 의존하는 경우 테스트하기가 매우 복잡해지며 복잡한 모의 객체를 만들어야 할 수도 있다.  
  
의존성을 줄이려면 메서드를 분리해야 한다. 특히 객체를 인스턴스화하는 메서드(주로 팩토리 메서드)와  
비즈니스 로직을 갖고 있는 메서드를 분리하는 것이 중요하다.
  
의존성 줄이기 예제  
car 패키지 -> Vehicle, Vehicle1 참조  
  
# **간단한 생성자 만들어 보기**  
car 패키지 -> Car 참조  
  
Car 클래스는 생성자에서 인스턴스 변수에 값을 할당하므로 아래 일을 수행한다.    
- 테스트할 클래스를 인스턴스화한다.  
- 클래스를 특정 상태로 설정한다.  
이는 설계 관점에서는 물론이고 클래스를 미리 정의한 상태로 가져오기 떄문에 좋지 못한 예제라고 볼 수 있다.  
클래스를 인스턴스화할 때마다 같은 일을 반복하기 떄문이다. 유지 보수나 테스트가 어려운 것은 물론이다.  
  
클래스를 특정 상태로 설정하는 것은 별도의 작업으로 분리해야 한다.  
car 패키지 -> Car1 참조  
  
# **데메테르 법칙 따르기**  
최소 지식의 법칙으로도 알려져 있는 데메테르 법칙은 클래스는 알아야 할 만큼의 정보만 가져야 한다는 것이다. 데메테르의 법칙은  
다음과 같이 설명할 수 있다.  
  
가까운 친구와 이야기하라 또는 낯선 이와 이야기하지 말라  
  
데메테르 법칙을 위반한 사례  
car 패키지 -> Car2 참조  
  
이 예제에서는 Context 객체를 Car 생성자에 전달한다. Context 객체는 드라이브에 대한 정보를 가지고 있다. 이 코드는  
데메테르 법칙을 위반하는데 Car 클래스가 Context 객체에 getDriver 메서드가 있다는 것을 알아야 하기 떄문이다.  
그러므로 Car 클래스의 생성자를 테스트하고 싶다면 생성자를 호출하기 전에 유효한 Context 객체를 가져오는 것이 선행되어야 한다.  
만약 Context 객체가 다양한 변수와 메서드를 갖는다면 Context 객체를 모사한 모의 객체를 사용해야 할지도 모른다.  
  
이런 상황에서 적절한 해결책은 데메테르 법칙을 적용하여 메서드나 생성자에 정확히 필요한 참조만 전달하는 것이다.  
이 사례에서는 Driver 객체만 Car 생성자에 전달해야 한다.  
  
Car(Driver driver)  
  
객체를 요구하되 객체 안에서 다시 찾지 않으며 현재 애플리케이션에 꼭 필요한 객체만 요청한다. 이것이 데메테르 법칙의 핵심이다.  
  
# **숨은 의존성과 전역 상태 피하기**  
전역 상태는 매우 주의해서 관리해야 한다. 정말 많은 클라이언트가 전역 객체를 사용할 수 있기 때문이다. 전역 상태를 공유하는 것은  
때때로 의도하지 않은 결과를 만들어 낸다. 공유 접근을 고려하지 않은 코드에서 전역 객체가 사용되거나 클라이언트가 전역 객체가  
배타적일 거라 생각하고 접근할 때는 더욱 위험하다.  
  
db 패키지 -> DBRun 클래스 참조  
  
구현 개선  
db 패키지 -> DBRun1 클래스 참조  
  
전역 상태는 되도록 피하는 게 좋다. 전역 객체에 대한 접근을 허용하면 단순히 전역 객체에만 접근을 공유하는 게 아니라 그 전역  
객체가 참조하는 모든 객체를 공유하게 되기 떄문이다.  
  
# **제네릭 메서드 사용하기**  
팩토리 메서드와 같은 정적 메서드는 매우 유용하지만 많은 정적 유틸 메서드에 문제가 있다. 단위 테스트는 격리된 테스트이다.  
코드에서 격리성을 갖기 위해서는 테스트 코드로 교체할 만한 연결 지점이 있어야 한다. 그리고 이런 경우엔 다형성을 활용하는 것이 도움이 된다.  
하나의 객체가 둘 이상의 IS-A 관계를 갖도록 만드는 다형성을 활용한다면 호출할 메서드가 컴파일 타임에 결정되지 않도록 만들 수 있다.  
다형성을 활용하여 애플리케이션 코드를 테스트 코드로 대체해 특정한 코드를 테스트해 볼 수 있다.  
  
그런데 정적 메서드만 사용한다면 반대 상황이 발생한다. 절차적 프로그래밍을 수행할 때처럼 메서드 호출이 거의 항상  
컴파일 타임에 결정된다. 코드를 유연하게 만드는 연결 지점이 없어지는 것이다.  
  
때로는 정적 메서드가 테스트에 미치는 영향이 크지 않을 수 있는데, 특히 Math.sqrt()처럼 그 자체로 완결성이 있는  
메서드는 더욱 그러하다. 그러나 복잡한 비즈니스 로직을 다루는 메서드나 정적 메서드 안에서 실행되고 있는 메서드들은  
테스트하기가 매우 까다롭다.  
  
정적 코드를 남발하거나 애플리케이션을 개발 시 다형성을 활용하지 못하면 애플리케이션뿐만 아니라 테스트에도 문제가  
생긴다. 다형성을 활용하지 않는다는 것은 애플리케이션과 테스트 모두에서 코드를 재사용하지 않는다는 뜻이기  
때문이다. 이런 상황은 애플리케이션과 테스트에서 코드 중복이 생길 수 있으므로 반드시 피해야 한다.  
  
결론적으로 파라미터에 구체적인 타입을 명시해야 하는 정적 유틸 메서드가 있다면 반드시 제네릭을 사용해야 한다.  
  
두 집합의 합집합을 반환하는 메서드  
`public static Set union(Seq s1, Set s2){

    Set result = new HashSet(s1);
    result.addAll(s2);
    return result;
}`
  
이 메서드는 컴파일은 되지만 타입 관련 경고가 나온다.  
메서드를 타입 체크로부터 안전하게 하고 경고를 없애려면 세 set에 대해 타입 파라미터를 선언한 다음 메서드에 타입 파라미터를  
사용하면 된다.  
  
`public static <E> Set<E> union(Set<E> s1, Set<E> s2{

    Set<E> result = new HashSet<>(s1);
    result.addAll(s2);
    return result;
}`  
  
제네릭 메서드를 사용하면 컴파일 시 경고가 뜨지도 않고 타입 안정성이 보장되며 사용 및 테스트하기가 쉽다.  
  
# **상속보다는 합성 활용하기**  
개발자들은 코드 재사용을 위해 상속을 활용하곤 한다. 그러나 상속보다는 합성이 테스트하기 쉽다. 런타임에 상속 구조를  
변경할 수는 없지만 객체를 다르게 합성하는 것이 가능하기 떄문이다. 결국 목표는 런타임 시 코드를 최대한 유연하게 만드는  
것이다. 합성을 사용하면 객체의 상태를 변화시키는 게 쉬워지고 테스트하기 쉬워진다.  
  
상위 클래스와 하위 클래스가 동일한 개발자의 제어하에 있는 패키지 내에 있다면 상속을 활용하는 게 바람직하다. 그러나  
패키지 밖의 구체 클래스를 상속하는 것은 위험할 수 있다.  
  
하위 클래스가 상위 클래스의 서브타입일 때 상속을 고려하는 것이 좋다. 클래스 A와 B가 있을 때 이를 연관지을 수 있는지  
생각해 보자. 클래스 B가 클래스 A를 상속해야 한다면 두 클래스 간에 IS-A 관계가 있어야 한다.  
  
자바 라이브러리에서 이 원칙을 어긴 경우도 있다. 스택은 벡터가 아니므로(IS-A 관계가 아니므로) Stack은 Vector를 상속해서는  
안 되었다. 마찬가지고 속성 리스트는 해시 테이블이 아니므로 Properties 클래스는 Hashtable 클래스를 상속해서는 안 되었다.  
두 경우 IS-A가 아닌 HAS-A 관계, 상속보다는 합성을 사용하는 것이 바람직하다.  
  
IS-A 관계 (상속 관계)  
하위 관계  
동물은 생물이다.  
고양이는 동물이다.  
  
HAS-A 관계 (구성 관계)   
포함하고 있음을 의미  
자동차는 엔진을 가진다.  
사람은 심장을 가진다.  
  
# **분기문보다는 다형성 활용하기**  
테스트에서 수행하는 작업은 다음 순서를 따른다.    
- 테스트할 클래스를 인스턴스화한다.  
- 클래스를 특정 상태로 설정한다.  
- 클래스의 최종 상태를 검증한다.  

문제는 세 단계 중 어느 곳에서도 발생할 수 있다. 예를 들어 클래스가 너무 복잡하면 인스턴스화가 어려울 수 있다.  
복잡도를 낮추기 위해서는 switch 문이나 if 문으로 길게 늘어진 분기문을 만들지 않으면 된다.  
  
나쁜 분기문 예제  
printer 패키지 -> bad 패키지 -> DocumentPrinter 클래스 참조  
  
분기문이 길고 복잡해진다면 다형성을 활용하는 것을 고려해 보자. 다형성은 객체를 여러 작은 클래스로 나누어 길고 복잡한 분기문을  
대체할 수 있게 해 주는데 이는 객체 지향 관점에서도 자연스럽다. 여러 작은 요소를 테스트하는 것은 크고 복잡한 요소를 테스트하는  
것보다 훨씬 쉽다.  
  
분기문 대체 예제  
printer 패키지 -> good 패키지 -> DocumentPrinter 클래스 참조  
  
# **TDD**  
테스트는 애플리케이션 설계를 발전시켜 나가는 데도 큰 도움이 된다. 단위 테스트를 많이 작성하다 보면 점차적으로 테스트를 코드보다  
먼저 작성하도록 스스로가 변하는 것을 느낄 것이다. 설계하고 구현하는 과정에서 어떻게 테스트할지 미리 염두에 두게 되는 것이다.  
이런 논리에 따라 테스트 친화적인 설계를 하던 많은 개발자들이 점차적으로 TDD로 이동하게 되었다.  
  
TDD  
개발자가 테스트를 먼저 작성한 다음 테스트를 통과하는 코드를 작성하는 프로그래밍 기법, 코드를 작성한 다음에는 코드를 검사하고  
난잡한 부분을 정리하거나 코드의 질을 높이기 위해 리펙토링한다. TDD의 목적은 작동하는 클린 코드를 만드는 것이다.  
  
# **개발 주기에 적응하기**  
개발자들은 보통 소스 코드를 개발할 때 API를 먼저 설계한 다음 서로 간에 약속한 동작을 구현하는 순서로 작업한다.  
코드를 단위 테스트할 때 API를 통해 약속한 동작을 수행하는지 검증할 수 있다. 도메인 코드가 API의 클라이언트가 되는  
것처럼 테스트 코드 역시 API의 클라이언트가 된다.  
  
통념적인 개발 주기  
코드를 작성한다, 테스트한다, (반복한다)  
  
TDD를 따르는 개발자는 약간 다른 주기를 갖는다.  
테스트한다, 코드를 작성한다, (반복한다)  
  
TDD에서의 테스트는 설계를 주도하고 메서드의 첫 번째 클라이언트가 된다. 이는 앞서 제시되었던 통속적인 소프트웨어 개발 방식이  
종종 요구 사항에 미치지 못하는 소스 코드를 만들어 내는 것과 대비된다.  
  
TDD로 개발할 때의 장점  
- 목적이 분명한 코드를 작성할 수 있고 개발자는 애플리케이션이 필요로 하는 것을 정확하게 개발했다는 확신을 얻을 수 있다.  
코드를 설계하는 데 테스트를 사용할 수 있다.  
- 새로운 기능을 더 빨리 적용할 수 있다. 테스트는 개발자가 의도대로 코드를 구현하게 유도하는 힘이 있다.  
- 테스트는 정상적으로 작동하는 기존 코드에 버그가 생기는 것을 방지할 수 있다.  
- 테스트는 개발 문서의 역할읗 한다. 테스트를 따르는 것은 소스 코드가 해결해야 하는 문제를 이해하는 것과 같다.  
  
# **TDD 2단계 수행하기**  
TDD는 실제 다음과 같이 진행된다.  
테스트한다, 코드를 작성한다, 리팩토링한다, (반복한다)  
  
리팩토링은 소프트웨어의 외적 동작을 바꾸지 않고 내부적인 구조만 개선함으로써 시스템을 변경하는 과정을 말한다.  
이때 외적 동작이 바뀌지 않았다는 것을 증명하기 위해서 테스트를 사용한다.  
  
TDD의 핵심 원리는 다음과 같다.  
- 새 코드를 작성하기 전에 실패하는 테스트를 먼저 작성한다.  
- 테스트를 통과하는 가장 단순한 코드를 작성한다.  
  
이 원리에 익숙한 개발자는 테스트에 기반하고 리팩토링이 잘된 코드가 본질적으로 변경하기 쉽고 안정적이라는 것을  
안다.  
  
# **실패하는 테스트부터 작성하기**  
실패하는 테스트를 마주했을 때 대부분은 테스트를 통과할 수 있는 가장 단순한 소스를 구현하기 시작한다. 그리고  
테스트가 통과되면 다음 과제로 넘어갈 수 있다. 전문가라면 새로 추가한 코드의 중복을 없애고 작성 의도를 명확하게  
하는 등 소스 코드를 최적화하기 위해 리팩토링하는 데 몇 분 정도 더 걸릴 것이다. 그러나 일단 테스트가 성공했다면  
소스 코드는 잘 작성된 것이다. 실패하는 테스트를 항상 먼저 작성하면 테스트에 성공하는 소스 코드만 작성할 수 있게 된다.  
  
# **행위 주도 개발**  
2000년대 중반 댄 노스(Dan North)가 주창한 BDD는 비즈니스 요구 사항을 직접적으로 만족하는 IT 솔루션을 만드는  
데에 집중한다. BDD의 철학은 비즈니스 전략, 요구 사항, 목표가 개발을 주도하며 이것들이 시나리오로 구체화된 다음에야  
IT 솔루션이 만들어진다는 것이다. TDD가 품질 좋은 소프트웨어를 만드는 데 기여한다면 BDD는 사용자의 문제를  
직접적으로 해결하는 소프트웨어를 만드는 데 기여한다.  
  
BDD 방법론을 잘 따르면 정말 중요한 것이 무엇인지 고민하고 그에 집중하는 방식으로 소스 코드를 작성할 수 있다.  
그리고 조직에 어떤 기능이 도움이 되는지, 이를 어떻게 효과적으로 구현할지 알 수 있을 것이다. 사용자가 요구하는  
것 이상을 보고 사용자가 필요한 것 이상을 구현ㅇ하게 된다.  
  
소프트웨어에 비즈니스적 가치를 제공하는 것은 바로 동작하는 기능(feature)이다. 기능은 비즈니스 목적을 달성하기  
위해 필요한 실체적이고 전달 가능한 서비스를 말한다. 또한 유지보수와 개선이 쉬운 소프트웨어가 소스 코드를 수정하면  
오류가 생길 가능성이 높은 소프트웨어보다 훨씬 가치 있으므로 BDD나 TDD 같은 방법론을 따르는 것은 훨씬 의미가 있다.  
  
비즈니스 목표를 설정하기 위해 비즈니스 분석가는 고객과 협의하여 비즈니스 목표를 달성할 수 있는 소프트웨어의 기능을  
결정한다.  
ex) 고객이 목적지로 가는 최적의 경로를 제공  
  
이런 기능은 보통 최종 단계의 요구 사항을 말한다. 그다음 이런 기능을 스토리로 잘게 쪼개야 한다.  
ex) 최단 시간 경로 찾기  
  
스토리는 구체적인 사례로 설명할 수 있어야 하며 구체적인 사례는 각 스토리의 인수 기준이 된다.  
키워드는 Given, When, Then을 사용하면 된다.  
인수 기준의 사례  
Given X회사에서 운항하는 항공편에서  
When 5월 15일부터 20일 사이에 부쿠레슈티에서 뉴욕으로 가는 가장 빠른 항공편을 찾는다면  
Then 부쿠레슈티-프랑크푸르트-뉴욕을 잇는 최단 경로를 보여준다  
  
# **돌연변이 테스트 수행하기**  
단위 테스트부터 인수 테스트까지 다양한 수준을 모두 테스트하고 코드 커버리지가 100%에 가까울 정도로 높다해도  
완벽한 작동을 보장하진 않는다. 여전히 테스트가 충분히 수행되지 않았을 수 있다. 이를 확인할 수 있는 가장 간단한  
방법은 테스트에서 JUnit 단언문을 삭제하는 것이다. 예를 들어 결괏값은 테스트에서 검증하기에 너무 복잡할 수 있으므로  
단순하게 표시하거나 로그로 처리하여 다음에 무엇을 할지 결정하게 하는 것이다.  
  
돌연변이 테스트는 돌연변이 분석, 돌연변이 프로그램이라고도 하는데 새 테스트를 설계하고 기존 테스트의 품질을  
평가하는 데 사용한다.  
  
돌연변이 테스트의 기본적인 아이디어는 프로그램을 조금 수정하는 것이다. 조금씩 변경된 프로그램들을 돌연변이  
(mutant)라고 부른다. 돌연변이는 원래 소스 코드와 다르게 동작하는 것이 당연하다. 이때 효과적인 테스트는  
돌연변이를 탐지하고 방지할 수 있는데 이를 돌연변이 죽이기(killing the mutant)라고 한다. 그리고 전체  
돌연변이의 숫자 중 죽은 돌연변이의 비율로 테스트의 가치를 측정할 수 있다. 돌연변이를 더 많이 죽이기 위해  
새로운 테스트를 설계할 수도 있다.  
  
돌연변이는 +를 -로 바꾸는 등 기존 연산자를 다른 연산자로 바꾸거나 if와 else의 내용을 바꾸는 등 일부 조건을  
뒤집는 등의 돌연변이 연산으로 만든다. 만약 돌연변이가 테스트를 통과한다면 테스트가 잘못된 것으로 간주할 수 있다.  
이렇게 돌연변이 테스트는 테스트의 신뢰성을 높이거나 테스트 데이터의 약점을 찾을 수 있으며 실행 중에 거의 혹은  
전혀 접근할 수 없었던 코드의 약점을 찾을 수도 있다. 돌연변이 테스트 역시 화이트박스 테스트의 일종이다.  
  
예를 들어 다음과 같은 코드가 주어졌을 때  
`if(a) {
    b = 1;
} else {
    b = 2;
}`  
  
돌연변이 연산은 조건을 뒤집어 새로 테스트할 내용이 다음과 같게 만든다.  
`if(!a){
    b = 1;
} else {
    b = 2;
}`  
  
훌륭한 돌연변이 테스트는 다음과 같은 프로세스를 따른다.  
1. 테스트 로직이 돌연변이가 된 if문을 탄다.  
2. 테스트는 초기의 정확한 분기와는 전혀 다른 곳에서 수행된다.  
3. b값이 달라졌고 엉뚱한 결과를 만든다.  
4. 메서드는 잘못된 값을 반환하므로 테스트가 실패한다.
  
제대로 된 테스트라면 돌연변이를 만들어 실행했을 때 반드시 실패해야 한다. 게다가 실패의 원인이 처음에 통과된  
분기 로직을 타지 않은 데 있다는 것도 보여 줄 수 있어야 한다.  
  
현재 자바 진영에서 가장 유명한 돌연변이 테스트 프레임워크는 Pitest다. Pitest는 자바 바이트 코드를 변경해서  
돌연변이를 만들어 낸다.  
  
# **개발 주기 내에서 테스트하기**  
테스트는 개발 주기 내에서 수행할 수 있으며 기본적으로 시간과 장소를 가리지 않는다.  
개발 주기는 다음과 같이 구분할 수 있다.  
  
- 개발(development): 개발은 주로 개발자의 작업 장소에서 이루어진다. 한 가지 중요한 원칙은 깃(Git), SVN,  
CVS, ClearCase 같은 SCM(source control management, 소스 코드 관리) 시스템에 하루에 여러 번 커밋(commit)  
하는 것이다. SCM에 커밋해 두면 다른 사람들도 작업을 사용할 수 있게 된다. 물론 작동하는 것만 커밋하는 것이 중요하다.  
커밋한 작업물의 작동을 보장하기 위해서는 저장소의 현재 코드와 변경 내역을 먼저 합쳐야 한다. 그다음 Maven이나 Gradle  
을 사용해 로컬에서 빌드한다. SCM 시스템에서 최신 변경 내역을 가져온 다음 자동화된 빌드 결과를 볼 수도 있다.  
  
- 통합(integration): 통합 단계에서는 다른 팀에서 개발한 컴포넌트까지 포함하여 애플리케이션을 빌드하고 여러  
컴포넌트가 함께 잘 작동하는지 확인한다. 이 단계가 정말 중요한데 여기서 문제가 자주 발생하기 때문이다. 통합 단계를  
자동화하는 것은 또 하나의 중요한 과제이며 이를 지속적 통합이라고 한다. 빌드 프로세스의 일부인 지속적 통합은  
애플리케이션을 자동으로 빌드하여 달성할 수 있다.  
  
- 인수/부하 테스트(acceptance/stress test): 프로젝트에서 리소스가 얼마나 사용 가능한지에 따라 하나 또는 두  
단계로 나눌 수 있다. 부하 테스트 단계에서는 애플리케이션에 부하를 주어 애플리케이션이 (사이즈나 응답 시간과 관련하여)  
적절하게 확장(scale)하는지 확인한다. 인수 단계는 프로젝트의 고객이 시스템을 인수하는 단계다. 인수 단계에서는  
가능한 한 자주 배포하는 것이 권장되는데 사용자의 피드백을 받을 수 있기 때문이다.  
  
- 예비 운영(pre-production): 예비 운영 단계는 실제 운영 배포 직전에 수행하는 마지막 검증 단계다. 이 단계는  
선택적으로 진행할 수 있으며 프로젝트의 중요도에 따라서 진행하지 않고 다음으로 넘어가도 무방하다.  
  
# **각 개발 주기에서 테스트 적용**  
개발 단계에서는 비즈니스 로직에 대해 단위 테스트(실제 운영 환경과 분리하여 실행할 수 있는 테스트)를 실행한다.  
보통 단위 테스트는 매우 빠르게 실행되며 일반적으로 IDE를 활용한다. 이때는 코드에서 변경한 사항이 다른 소스 코드를  
망치는 일이 없는지 확인한다. 이러한 테스트는 코드를 SCM에 커밋하기 전에 자동화된 빌드에서도 수행할 수 있다.  
통합 테스트를 실행할 수도 있다. 그러나 이 경우에는 데이터베이스나 애플리케이션 서버 등 운영 환경을 모사한  
환경이 필요하므로 테스트 수행 시간이 좀 더 오래 걸릴 수 있다. 실제로는 추가된 통합 테스트 정도만 실행하기도  
한다.  
  
통합 단계에서는 일반적으로 자동화된 빌드를 수행하여 애플리케이션을 패키징하고 배포한다. 그다음 단위 테스트와  
기능 테스트를 수행한다. 기능 테스트는 시스템이나 구성 요소가 요구 사항을 잘 지키고 있는지 평가하는 것이다.  
기능 테스트는 블랙박스 테스트의 일종으로 시스템이 제공하는 기능을 테스트한다. 일반적으로 통합 단계에서는  
기능 테스트의 일부만 실행한다. 운영 단계에 비해 통합 단계에서는 몇몇 요소가 빠져 있기 때문이다. (예를 들어  
접근해야 하는 외부 시스템에 대한 연결이 누락되었을 수 있다). 통합 단계에서 모든 테스트를 실행할 수도 있다.  
이 경우 시간은 그리 중요한 것이 아니며 전체 빌드는 개발에 아무런 영향을 미치지 않고 몇 시간씩 걸릴 수 있다.  
  
인수/부하 테스트 단계에서는 통합 단계에서 실행한 것과 동일한 테스트를 수행한다. 또한 이때는 소프트웨어의 성능과  
견고함을 확인하기 위해서 부하 테스트를 추가적으로 실행하기도 한다. 인수 단계는 운영 단계와 정말 비슷하고 이 단계에서  
더욱 많은 기능 테스트를 수행할 수 있다.  
  
모범 사례는 인수 단계에서 실행한 테스트를 예비 운영 단계에서도 실행하는 것이다. 그렇게 함으로써 모든 것이  
올바르게 설정되었는지를 확인할 수 있으며 완전성을 검증한다고 볼 수 있다.  
  
이상적으로는 모든 것을 완벽하게 하려면 네 가지 단계에 맞는 테스트를 일일이 수행해야 한다.
  







  
